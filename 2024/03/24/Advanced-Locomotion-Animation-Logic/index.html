<!DOCTYPE html><html class="appearance-dark" lang="zh-CN"><head><meta charset="UTF-8"><title>进阶运动动画的实现</title><meta name="description" content="致力于减少重复性工作"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="自虚幻引擎5发布以来，Epic 官方提供了很多实用的工具来处理动画资产，在初学者项目 Lyra 中不仅可以看到这些工具的具体应用，还提供了一个进阶版本的动画逻辑解决方案（相较于第三人称射击模板附带的动画蓝图）。本博文主要讨论这套方案的以下几个要点：

如何修改动画序列数据以满足该解决方案的资产要求；
如何减轻游戏主线程的负担，让动画逻辑不成为性能瓶颈；
如何在运行时灵活地替换部分动画，例如玩家装备武器时，将无持械的动画替换为该武器对应的动画。

为了使这套解决方案可以正确工作，以及方便动画资产的处理，需要项目启用Animation Locomotion Library、Animation Warping、Animation Modifier Library插件。本解决方案对应的角色旋转设置如下：
// 角色.."><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Yerha's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">进阶运动动画的实现</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97%E8%B5%84%E4%BA%A7"><span class="toc-text">动画序列资产</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E8%93%9D%E5%9B%BE%E4%B8%8E%E5%8A%A8%E7%94%BB%E5%B1%82"><span class="toc-text">动画蓝图与动画层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%93%BE%E6%8E%A5%E5%8A%A8%E7%94%BB%E5%B1%82"><span class="toc-text">在运行时链接动画层</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Unreal"><i class="tag post-item-tag">Unreal</i></a><a href="/tags/Animation"><i class="tag post-item-tag">Animation</i></a><a href="/tags/Lyra"><i class="tag post-item-tag">Lyra</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">进阶运动动画的实现</h1><time class="has-text-grey" datetime="2024-03-24T02:07:38.000Z">2024-03-24</time><article class="mt-2 post-content"><p>自虚幻引擎5发布以来，Epic 官方提供了很多实用的工具来处理动画资产，在初学者项目 Lyra 中不仅可以看到这些工具的具体应用，还提供了一个进阶版本的动画逻辑解决方案（相较于第三人称射击模板附带的动画蓝图）。本博文主要讨论这套方案的以下几个要点：</p>
<ul>
<li>如何修改动画序列数据以满足该解决方案的资产要求；</li>
<li>如何减轻游戏主线程的负担，让动画逻辑不成为性能瓶颈；</li>
<li>如何在运行时灵活地替换部分动画，例如玩家装备武器时，将无持械的动画替换为该武器对应的动画。</li>
</ul>
<p>为了使这套解决方案可以正确工作，以及方便动画资产的处理，需要项目启用<code>Animation Locomotion Library</code>、<code>Animation Warping</code>、<code>Animation Modifier Library</code>插件。本解决方案对应的角色旋转设置如下：</p>
<pre><code class="hljs CPP"><span class="hljs-comment">// 角色的朝向跟随 ControllRotation</span>
bUseControllerRotationYaw = <span class="hljs-literal">true</span>;
<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; CharMovement = <span class="hljs-built_in">GetCharacterMovement</span>();
CharMovement-&gt;bOrientRotationToMovement = <span class="hljs-literal">false</span>;</code></pre>

<h2 id="动画序列资产"><a href="#动画序列资产" class="headerlink" title="动画序列资产"></a>动画序列资产</h2><p>在 Lyra 中，角色的地面运动主要分为站立步行（Walk）、站立奔跑（Jog）和蹲下行走（Crouch）三种姿态，每种姿态都有空闲（Idle）和前后左右的开始（Start）、运动（Cycle）、结束（Stop）、枢轴（Pivot）动画。在开始、结束和枢轴动画中要求资产有名为 Distance 的曲线，标志着在当前帧在动画里移动的距离。这会在运行时通过计算真实运动的距离来调整序列的播放进度，比如角色停下需要往前走 100 厘米才能将速度大小降为零，在动画蓝图中需要找到 100 厘米对应的帧是多少然后从那里开始播放，还会在每帧根据移动距离随时调整播放进度。枢轴主要处理在运动状态下加速度与速度方向角度大于九十度时的情况，例如在往前走的状态中，玩家输入了往后走时，需要表现出先成往前跑的姿势停下来，然后再开始往后跑的姿势。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/showcase_distance_curve.png"></p>
<p>在制作这样的曲线前，需要先定义一个<code>Curve Compression Settings</code>，并设置编码方式为 Uniform Indexable，这是虚幻引擎在文档中的要求，以确保可以在运行时访问到曲线信息。具体是在内容浏览器中按下鼠标右键，依次选择 Animation / Advanced / Curve Compression Settings，双击打开新资产为 Codec 设置 Uniform Indexable。所有需要使用曲线信息的动画序列里，Asset Details / Compression / Curve Compression Settings 赋为新建的压缩设置。对于多个动画序列资产，可以选中它们然后右键 Asset Actions / Edit Selection in Property Matrix，以实现批量修改。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/curve_compression_settings_in_property_matrix.png"></p>
<p>制作这样的曲线，并不需要我们手动绘制。在动画序列编辑器中 Window 菜单下有一个 Animation Data Modifier 选项，点击它就会出现一个窗口，在这个窗口下可以借助一系列的修改器生成符合满足需求的曲线、轨道（Track）和通知（Notify）。其中就有一个<code>DistanceCurveModifier</code>，它就可以自动生成我们需要的曲线。在 Asset Details 中勾选<code>Enable Root Motion</code>选项后就可以右键应用修改器了。同样如果多个序列都需要这样的设置时，可以先用上文提到的 Property Matrix 来勾选<code>Enable Root Motion</code>后，对这些右键选择 Animation Modifier(s) / Add New Modifiers 来添加和应用修改器。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/distance_curve_modifier_UI.png"></p>
<p>除了创建 Distance 曲线，推荐进一步应用<code>SyncMarkerAnimModifier</code>，它会创建一个<code>FootSyncMarkers</code>轨道并在里面创建若干个标记为 L 和 R 的通知，后期在动画蓝图中选择同步组后，就可以实现不同动画之间过渡时能匹配姿势，产生连贯地动画。</p>
<p>除了地面运动外，还有一些跳跃有关的动画，分别是跳跃开始（JumpStart）、跳跃开始循环（JumpStartLoop）、跳跃到极点（JumpApex）、下落循环（FallLoop）以及下落着陆（FallLand）。可以为这些资产加上 <code>DistableFootIK</code>的曲线，确保腿部不会尝试寻找可以落脚的位置。而对于下落着陆动画中还需要添加一个<code>GroundDistance</code>的曲线，表示每一帧到地面的距离，在实际下落时可以计算到地面的距离值来调整播放进度。这同样是通过<code>DistanceCurveModifier</code>实现的，在配置中设置轴（Axis）为<code>Z</code>即可。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/ground_distance_in_fall_land_sequence.png"></p>
<h2 id="动画蓝图与动画层"><a href="#动画蓝图与动画层" class="headerlink" title="动画蓝图与动画层"></a>动画蓝图与动画层</h2><p>与本博文讨论话题有关的动画相关类有三个，它们分别是：</p>
<ul>
<li><code>ABP_Mannequin_Base</code>：派生自 AnimInstance，作为角色骨骼网格组件的动画蓝图类。获取和计算 AnimGraph 使用的变量。而 AnimGraph 作为一个总的动画框架，包含运动（Locomotion）状态机、相加姿势（Additive Pose）融合、根旋转（Root Rotate）以及一些蒙太奇槽位的连接。<strong>但这里并没有具体的动画姿势</strong>，所有需要动画姿势的位置都连接了动画层接口（AnimLayersInterface）中的一个动画层。</li>
<li><code>ALI_ItemAnimLayers</code>：作为一个动画层接口，里面定义了一系列姿势输入与输出的动画层。可以这么思考，动画层相当于接口类中的虚函数，但必须要返回一个姿势，是否有输入姿势或其他变量则作为可选项。继承了这个接口的动画蓝图类可以使用动画层（类似调用）作为节点的输入。也可以实现接口，在运行时动态的链接（Link）到使用动画层的动画蓝图。在本例中<code>ABP_ItemAnimLayersBase</code>实现了所有的动画层，输出姿势给<code>ABP_Mannequin_Base</code>使用，后者使用动画层作为自己 AnimGraph 中一些节点的输入。</li>
<li><code>ABP_ItemAnimLayersBase</code>：派生自 AnimInstance。作为 ALI_ItemAnimLayers 的一个实现类，对于接口中的每个动画层都提供了有效的输出。它作为一种基类存在，将具体的姿势暴露为一个个变量，而派生类只需要为这些变量赋值即可。例如，<code>ABP_PistolAnimLayers</code>派生类只是给变量赋值，提供了角色装备手枪时的站立、运动、跳跃等动画。</li>
</ul>
<p>Lyra 并不是一个专注于射击的游戏，它支持使用<code>GameFeature</code>来增加更多的游戏玩法，官方示例中除了死斗、占点模式外，还有一个玩法完全不一样的炸弹人（类似QQ堂）模式，也允许开发者增加更多的玩法。因此，<code>ABP_Mannequin_Base</code>动画蓝图中获取与计算的变量较为基础，一些与射击模式有关的变量获取与计算工作留给了<code>ABP_ItemAnimLayersBase</code>来完成，后者与射击模式有关。如果游戏项目专门是射击玩法的话，可以考虑将<code>ABP_ItemAnimLayersBase</code>中计算变量的逻辑迁移到<code>ABP_Mannequin_Base</code>，使前者可以专注于生成姿势的逻辑。</p>
<hr>
<p>打开动画蓝图时，会发现 EventGraph 没有任何逻辑在执行。原先会在<code>BlueprintUpdateAnimation</code>中进行的逻辑，现在在<code>BlueprintThreadSafeUpdateAnimation</code>完成了，后者在逻辑中会利用多线程来分摊数据的计算，减轻了游戏主线程的负担。在这个函数中需要注意以下三点：</p>
<ul>
<li>获取外部函数和变量的值使用<code>PropertyAccess</code>节点来访问。据虚幻引擎官方介绍，该节点会在 Update 函数执行之前会对相关的变量进行缓存，读取缓存时的数据，这样一定程度上避免了数据竞争的问题，总之被官方定义为是线程安全的访问形式。</li>
<li>在该函数中执行的函数要勾选 Advanced / Thread Safe，线程安全的函数访问外部数据时只能使用<code>PropertyAccess</code>进行。</li>
<li>如果想定义可以在<code>PropertyAccess</code>节点中选择的函数，它必须是线程安全的、没有形参，返回值的名称必须是<code>ReturnValue</code>。对返回值的名称要求暂不清楚这是刻意的行为还是软件错误，如果不是这个名称则无法调用。在本例中<code>ABP_Mannequin_Base</code>定义了返回<code>UCharacterMovementComponent</code>实例的函数，而<code>ABP_ItemAnimLayersBase</code>也需要使用这个实例，但它只能使用<code>PropertyAccess</code>的形式来调用<code>ABP_Mannequin_Base</code>定义的函数。</li>
</ul>
<p>本节接下来的内容是谈论对一些变量的理解，如果不需要可以跳到下一节。</p>
<hr>
<p>在 Lyra 的实现中并不会有空闲、步行到奔跑的渐变过渡，或者说并没有一个混合空间（BlendSpace）来处理速度从 0 到 Max Walk Speed 的过渡，而是根据用户的输入直接在一帧内直接切换到另一种速度的姿态。这是基于游戏玩法设计的需求，角色的运动组件中加速度大小的增量被设置为了 2048 cm，这意味着步行的动画还没有播放几帧就已经完全在播放奔跑的了。而步行的姿态只会在一个名为<code>GameplayTag_is_ADS</code>布尔变量为 true 时播放，玩家进行精准瞄准（例如按下鼠标右键）或者静步走时会获得对应类似的标签，角色类会检查是否获得了这个标签从而改变 <code>GameplayTag_is_ADS</code>的值。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/cycle_sequence_player_select_anim_sequence.png"></p>
<hr>
<p>这里也没有四个方向运动的渐变过渡，而是计算局部速度方向角度值来设置一个 <code>AnimEnum_CardinalDirection</code>类型的枚举变量 <code>LocalVelocityDirectionNoOffset</code>，里面枚举值分别是前（Forward）、后（Backward）、左（Left）和右（Right）。在设置该枚举变量的函数<code>SelectCardinalDirectionFromAngle</code>可以发现，如果玩家持续向前或向后运动的时候，将会更难切换到向左或向右的动画，这减少了频繁切换动画的情况发生。而在混合空间中很难（好像不可能）在运行时调整各个采样的坐标。而为了让姿势更加自然，输出的姿势引脚接入了 <code>Orientation Warping</code> 节点，它会根据局部速度方向角度值来旋转角色的朝向。在浏览<code>SelectCardinalDirectionFromAngle</code>函数时，需要注意的是：1. 形参 Angle 是[-180,180]的值，正面角度是 0，反面是 -180 或 180，右面是 90，左面是 -90；2. 在判断正反面使用的是 Angle 的<strong>绝对值</strong>，但判断左右面的时候用的是 Angle <strong>原值</strong>，在复现时这里有可能会误用绝对值版本。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/select_cardinal_direction_focus_on_enlarge_dead_zone.png"><br><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/cycle_output_connects_orientation_warping.png"></p>
<hr>
<p>在<code>UpdateCharacterStateData</code>函数中可以看到，角色在竖直方向（z）的速度方向是正还是反来区分是跳跃还是下落的状态。紧接着在<code>UpdateJumpFallData</code>函数中可以看到在跳跃状态时，会以竖直方向速度大小的相反数除以重力Z值（重力值是负值，表示竖直向下的方向），作为从跳跃开始循环到跳跃极点两个动画状态之间的转换条件。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/update_jump_fall_data.png"><br><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/jump_start_loop_to_jump_apex.png"></p>
<hr>
<p>在<code>UpdateRootYawOffset</code>函数中可以看到<code>RootYawOffsetMode</code>变量的更新方法，这个变量是<code>AnimEnum_RootYawOffsetMode</code>枚举类型，一共有<code>Accmulate</code>、<code>Hold</code>和<code>BlendOut</code>三个枚举值。在外部修改这个变量时也只会是<code>Accumulate</code>和<code>Hold</code>之间的一个，前者会累加角色旋转体（Rotator）的 Yaw 值到<code>RootYawOffset</code>值上，后者保持<code>RootYawOffset</code>当前值。无论是哪一种选项，最后都会修改成<code>BlendOut</code>值，意味着下一帧如果没有修改该枚举变量的话，它会从当前的值线性插值到 0。在实际运用中，会在休闲状态（Idle）中锁在<code>Accumulate</code>值，这样旋转摄影机可以看到角色的各个面，因为根骨骼正在与摄影机在 Yaw 轴上进行相反的旋转。在开始状态（Start）时锁到<code>Hold</code>值，以当时的旋转值播放开始姿势。在运动状态（Cycle）中没有锁住该枚举变量的值，因此根骨骼会慢慢插值回到摄影机看向的方向。在停止状态（Stop）开始锁为<code>Accumulate</code>值，这样停止动画期间就可以旋转视角而不会影响角色旋转了。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-update_root_yaw_offset.png"></p>
<hr>
<p><code>LinkedLayerChanged</code>和<code>LastLinkedLayer</code>两个变量与运行时是否链接了新动画层有关，它们的更新时机是在 LocomotionSM 状态机的<code>OnUpdate</code>绑定函数中（单击状态机后在细节面板中可以找到），在内部会发现一个<code>StartLayerNode</code>的动画节点引用，在那里会检查是否与之前存储的动画层引用相同，进而触发修改逻辑。关键在于这个引用节点的创建方式，实际上它指向的是 LocomotionSM / Start 中的 FullBody_StartState，在它的细节面板中可以看到<code>Tag</code>条目，为它指定一个名字就可以在动画蓝图中引用它了。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-on_locomotionSM_update.png"></p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-fullbody_startstate_tag.png"></p>
<hr>
<p>最后需要了解的是，动画蓝图中大量使用了<code>Sequence Player</code>和<code>Sequence Evaluator</code>节点，可简单地理解为前者可以播放一个动画序列，后者在前者基础上可以更改播放起始点。为了实现动态地的更换播放的资产和调整播放时间，因此它们在细节面板中<code>Sequence</code>和<code>Explicit Time</code>（仅限 Evaluator）都会更改成<code>Dynamic</code>形式。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-sequence_player_set_dynamic.png"></p>
<p>对于这两个播放节点会绑定<code>On Become Relevant</code>和<code>On Update</code>函数：前者代表这个序列开始贡献姿势的第一帧，也就是权重值不再是 0% 了；后者就是每帧都会调用的函数。在函数内部通常对<code>Node</code>形参调用<code>Convert to Sequence Player</code> 或 <code>Convert to Sequence Evaluator</code>，从而进一步设置播放的 Sequence 以及设置 Explicit Time（仅限 Evaluator）。在上文中讲述过开始、停止和枢轴动画中加入了 Distance 曲线。对于它们来说我们可以在<code>Sequence Evaluator</code>的<code>On Update</code>函数中调用<code>Advance Time by Distance Matching</code>节点，将当前帧与上一帧角色移动的位置差作为参数就可以转换为播放的帧起始点。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-Advance_Time_by_Distance_Matching.png"></p>
<p>对于停止动画会使用<code>Predict Ground Movement Stop Location</code>来计算出停止的位置出，得到向量长度后可以使用<code>Distance Match to Target</code>节点来调整<code>Explicit Time</code>。在 Lyra 中计算距离值的逻辑封装为了<code>Get Predicted Stop Distance</code>函数。</p>
<p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-get_predicted_stop_distance.png"></p>
<h2 id="在运行时链接动画层"><a href="#在运行时链接动画层" class="headerlink" title="在运行时链接动画层"></a>在运行时链接动画层</h2><p>在 Lyra 解决方案中，角色类使用的动画蓝图类是<code>ABP_Mannequin_Base</code>，但从上一节的描述中已经知道这个蓝图类中没有具体的动画资产，所以直接使用只会得到 T-Pose。为了链接到实现了动画层的动画蓝图，可以使用下面的函数来动态的链接和取消链接动画蓝图：</p>
<pre><code class="hljs CPP"><span class="hljs-comment">// 参数为实现了动画层的动画蓝图类</span>
<span class="hljs-built_in">GetMesh</span>()-&gt;<span class="hljs-built_in">LinkAnimClassLayers</span>(); 
<span class="hljs-built_in">GetMesh</span>()-&gt;<span class="hljs-built_in">UnlinkAnimClassLayers</span>();</code></pre>
<p>但直接调用这个函数并不会进行网络同步，需要定义一个<code>NetMulticast</code>函数来确保所有客户端中都可以看到这个链接函数。以下是一个示例，如果第二个参数为 true 就调用 Link 函数，否则就调用 Unlink 函数：</p>
<pre><code class="hljs CPP"><span class="hljs-built_in">UFUNCTION</span>(NetMulticast, Reliable)
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Multicast_SetMeshCompAnimLayers</span><span class="hljs-params">(TSubclassOf&lt;UAnimInstance&gt; InClass, <span class="hljs-type">bool</span> bLinkIt = <span class="hljs-literal">true</span>)</span></span>;</code></pre>

<p>可装备道具在设计时可以加入一个 TSubclassOf<uaniminstance> 类型的变量，要求设计师指定一个实现了动画层的动画蓝图类，在运行时调用<code>Multicast_SetMeshCompAnimLayers</code>函数以便于动态地调整姿势。</uaniminstance></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2024/04/07/binding-IA-to-GA/" title="如何用 InputAction 来触发 GameplayAbility 的激活"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 如何用 InputAction 来触发 GameplayAbility 的激活</span></a><a class="button is-default" href="/2024/03/10/Implement_Building_System_With_GAS/" title="如何将建造功能作为一种技能"><span class="has-text-weight-semibold">下一页: 如何将建造功能作为一种技能</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/yerha"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Yerha 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>