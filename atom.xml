<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.yerha.top/atom.xml" rel="self"/>
  
  <link href="http://www.yerha.top/"/>
  <updated>2024-04-09T04:08:29.407Z</updated>
  <id>http://www.yerha.top/</id>
  
  <author>
    <name>Yerha</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>道具使用 UObject 还是 UStruct</title>
    <link href="http://www.yerha.top/2024/04/09/uobject-vs-ustruct-for-storing-item-instance-data/"/>
    <id>http://www.yerha.top/2024/04/09/uobject-vs-ustruct-for-storing-item-instance-data/</id>
    <published>2024-04-09T02:34:00.000Z</published>
    <updated>2024-04-09T04:08:29.407Z</updated>
    
    <content type="html"><![CDATA[<p>尽管 C++ 本身视 <code>class</code> 和 <code>struct</code> 都为类类型，区别只在默认访问修饰符（class 默认为 private，struct 默认为 public）。但在虚幻引擎中却有所不同，<code>UObject</code> 使用 <code>class</code> 作为类类型的修饰符，而 <code>UStruct</code> 使用 <code>struct</code> 作为类类型的修饰符（请注意这里没有讨论 Slate 相关的类体系结构），就会在反射机制、网络复制方面产生不同的区分，本博文在构建道具类型的基础下，讨论以下内容：</p><ul><li>如何维护它们的生命周期；</li><li>如何在网络中复制它们。</li></ul><h2 id="物品的信息"><a href="#物品的信息" class="headerlink" title="物品的信息"></a>物品的信息</h2><p>在绝大多数情况下，物品信息可以用一个结构体来定义（C++中需要派生自 <code>FTableRowBase</code>），然后定义基于该结构体的 DataTable，这种方式不仅可以实现统一的数据管理，还允许从外界来修改物品信息，在需要使用物品信息的位置处定义一个 <code>FDataTableRowHandle</code> 实例即可对 DataTable 中的行进行引用。但取而代之的是，引擎每次启动都会加载所有的物品信息，造成加载时间变长；DataTable 有一个独立于结构体的 RowName 列，因此开发者需要引入约定来确定 “空”是什么，是 RowName 为 <code>Empty</code> 还是结构体中其中一个作为标识符的成员为无效值；存储 <code>FDataTableRowHandle</code> 并不能保证得到的信息就是物品信息，因为它允许设置来自哪个数据表和行名，对于输出行只能假设为是物体信息有关的结构体（我们无法使用 <code>Cast</code> 的结果来判断是否为预期的类型）。</p><p>还有一个可选方案是使用 <code>UPrimaryDataAsset</code> 类型，定义的数据变量可以全部用于描述物品的信息（相比较 DataTable 多了 RowName），可以用常见约定 <code>nullptr</code> 为空对象。这种类型下，我们还允许通过配置 <code>UPROPERTY</code> 来使一些数据成员隐藏起来，例如在下面的代码中允许设计师设置物体使用 <code>StaticMesh</code> 或 <code>SkeletalMesh</code> 网格资产，从而隐藏另一项以达到更加友好的编辑界面：</p><pre><code class="hljs CPP"><span class="hljs-built_in">UENUM</span>(BlueprintType)<span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EMeshType</span> : uint8{Skeletal,Static};<span class="hljs-built_in">UCLASS</span>()<span class="hljs-keyword">class</span> <span class="hljs-title class_">BOTA_API</span> UBota_ItemDataAsset : <span class="hljs-keyword">public</span> UPrimaryDataAsset{<span class="hljs-built_in">GENERATED_BODY</span>()<span class="hljs-keyword">public</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> FPrimaryAssetId <span class="hljs-title">GetPrimaryAssetId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">FPrimaryAssetId</span>(<span class="hljs-string">"Bota_ItemDataAsset"</span>, <span class="hljs-built_in">GetFName</span>());};<span class="hljs-keyword">protected</span>:<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PostEditChangeProperty</span><span class="hljs-params">(FPropertyChangedEvent&amp; PropertyChangedEvent)</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = <span class="hljs-string">"Info"</span>)FText DisplayName;<span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = <span class="hljs-string">"Info"</span>)EMeshType MeshType;<span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = <span class="hljs-string">"Info"</span>, meta = (EditCondition = <span class="hljs-string">"MeshType == EMeshType::Skeletal"</span>, EditConditionHides))TSoftObjectPtr&lt;USkeletalMesh&gt; SkeletalMesh;<span class="hljs-built_in">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = <span class="hljs-string">"Info"</span>, meta = (EditCondition = <span class="hljs-string">"MeshType == EMeshType::Static"</span>, EditConditionHides))TSoftObjectPtr&lt;UStaticMesh&gt; StaticMesh;};<span class="hljs-comment">// 当设计师选择一项时，将另一项的值清空。这样在创建物品 Actor 时就不需要检查 EMeshType 的值，直接对两种网格组件调用设置网格函数即可。</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_ItemDataAsset::PostEditChangeProperty</span><span class="hljs-params">(FPropertyChangedEvent&amp; PropertyChangedEvent)</span></span><span class="hljs-function"></span>{    Super::<span class="hljs-built_in">PostEditChangeProperty</span>(PropertyChangedEvent);    <span class="hljs-keyword">if</span> (PropertyChangedEvent.<span class="hljs-built_in">GetPropertyName</span>() == <span class="hljs-built_in">GET_MEMBER_NAME_CHECKED</span>(ThisClass, MeshType))    {        <span class="hljs-keyword">if</span> (MeshType == EMeshType::Static)        {            SkeletalMesh = <span class="hljs-literal">nullptr</span>;        }        <span class="hljs-keyword">else</span>        {            StaticMesh = <span class="hljs-literal">nullptr</span>;        }    }</code></pre><p>将物品信息都为单独一个资产时，我们还可以进一步地允许将资产拖拽到场景中，创建使用这个道具信息的道具 Actor。只需要定义一个派生自 <code>UActorFactory</code> 的类，然后覆盖 <code>CanCreateActorFrom</code> 和 <code>PostSpawnActor</code> 函数即可，以下是一个示例：</p><pre><code class="hljs CPP">UBota_ItemActorFactory::<span class="hljs-built_in">UBota_ItemActorFactory</span>(){NewActorClass = ABota_ItemActor::<span class="hljs-built_in">StaticClass</span>();}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UBota_ItemActorFactory::CanCreateActorFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> FAssetData&amp; AssetData, FText&amp; OutErrorMsg)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (!AssetData.<span class="hljs-built_in">IsValid</span>())<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (!AssetData.<span class="hljs-built_in">GetClass</span>()-&gt;<span class="hljs-built_in">IsChildOf</span>(UBota_ItemDataAsset::<span class="hljs-built_in">StaticClass</span>())){OutErrorMsg = <span class="hljs-built_in">NSLOCTEXT</span>(<span class="hljs-string">"CanCreateActor"</span>, <span class="hljs-string">"WrongType"</span>, <span class="hljs-string">"Asset must be a UBota_ItemDataAsset."</span>);<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;}<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_ItemActorFactory::PostSpawnActor</span><span class="hljs-params">(UObject* Asset, AActor* NewActor)</span></span><span class="hljs-function"></span>{<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Data = <span class="hljs-built_in">Cast</span>&lt;UBota_ItemDataAsset&gt;(Asset);<span class="hljs-keyword">auto</span> Actor = <span class="hljs-built_in">Cast</span>&lt;ABota_ItemActor&gt;(NewActor);<span class="hljs-keyword">if</span> (!Data || !Actor)<span class="hljs-keyword">return</span>;Actor-&gt;DefaultItemDataAsset = Data;}</code></pre><h2 id="物品的实例"><a href="#物品的实例" class="headerlink" title="物品的实例"></a>物品的实例</h2><p>讨论完物品信息的存储方式后，该讨论讨论如何存储物品的实例了，在实例中除了包含物品信息外，还有例如物品数量、物品耐久度、弹药量等数据成员。目前，绝大部分的实现中也是使用结构体来存储，在这种设计中结构体扮演着“大师（Master）”的身份，所有的道具都使用全部的数据成员，比如说资源类道具（例如木头、石头）也会拥有弹药量信息，只是它不会使用而已。虚幻引擎中 UStruct 使用另一套垃圾回收机制，我们得使用 <code>TSharedPtr</code> 和 <code>TSharedRef</code> 等智能指针来维护它们。但这里需要考虑的是，是不是值得构建一个继承体系来适应不同的物品实例信息，只为了少存储几个字节，反而会增加类型识别和转换的工作（也会增加程序错误的概率）。在这里，我更倾向于物品实例类型是一个“大师”类型，即它存有物品所用到的所有信息。</p><p>通常来说使用了结构体后，只要标记为 <code>Replicated</code> 就可以保证网络复制了，因为无论是角色类还是物品栏的容器中，我们存储的都是结构体实例，而不是指向或绑定到结构体的指针或引用，只要保证远程过程调用中确保传递是绑定到结构体实例的引用（例如 <code>const FBota_ItemInstance&amp;</code>），以及确保移动时在原位置处进行清除的工作即可。</p><p>如果一定要构建继承体系来维护道具实例，使用自定义的 <code>UObject</code> 会更好，因为我们可以使用相同的反射机制来维护道具实例。但这里需要注意的是，虚幻引擎中并不是所有的 <code>UObject</code> 都支持进行网络复制，想要自定义的 <code>UObject</code> 支持网络复制在类本身中表示能支持网络功能，还像在组件或 Actor 那样覆盖 <code>GetLifetimeReplicatedProps</code> 函数，以下是一个示例：</p><pre><code class="hljs CPP"><span class="hljs-comment">// header file</span><span class="hljs-built_in">UCLASS</span>(BlueprintType)<span class="hljs-keyword">class</span> <span class="hljs-title class_">BOTA_API</span> UBota_ItemSpec : <span class="hljs-keyword">public</span> UObject{<span class="hljs-built_in">GENERATED_BODY</span>()<span class="hljs-keyword">public</span>:<span class="hljs-built_in">UBota_ItemSpec</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">IsSupportedForNetworking</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt; <span class="hljs-keyword">class</span> FLifetimeProperty &gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Replicated)TObjectPtr&lt;UBota_ItemDataAsset&gt; ItemDataAsset;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Replicated)int32 ItemAmount = <span class="hljs-number">0</span>;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Replicated)<span class="hljs-type">bool</span> bIsEquipped = <span class="hljs-literal">false</span>;};<span class="hljs-comment">// cpp file</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UBota_ItemSpec::IsSupportedForNetworking</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>{    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_ItemSpec::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>{    Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);    <span class="hljs-built_in">DOREPLIFETIME</span>(ThisClass, ItemDataAsset);    <span class="hljs-built_in">DOREPLIFETIME</span>(ThisClass, ItemAmount);    <span class="hljs-built_in">DOREPLIFETIME</span>(ThisClass, bIsEquipped);}</code></pre><p>完成以上这些还不能实现将物品实例进行网络复制，我们需要借助 Actor 的网络通道来复制 UObject 才可以。这意味着，<code>UBota_ItemSpec</code> 出现的任何位置（Actor 或 ActorComponent ）都需要进行编写类似以下的代码：</p><pre><code class="hljs CPP"><span class="hljs-comment">// ABota_ItemActor 存储着 TObjectPtr&lt;UBota_ItemSpec&gt; ItemSpec，并标记了 Replicated。</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_ItemActor::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>{Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<span class="hljs-built_in">DOREPLIFETIME</span>(ThisClass, ItemSpec);}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ABota_ItemActor::ReplicateSubobjects</span><span class="hljs-params">(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)</span></span><span class="hljs-function"></span>{<span class="hljs-type">bool</span> bWroteSomething = Super::<span class="hljs-built_in">ReplicateSubobjects</span>(Channel, Bunch, RepFlags);<span class="hljs-keyword">if</span> (ItemSpec){bWroteSomething |= Channel-&gt;<span class="hljs-built_in">ReplicateSubobject</span>(ItemSpec, *Bunch, *RepFlags);}<span class="hljs-keyword">return</span> bWroteSomething;}<span class="hljs-comment">// UBota_InventoryComponent 存储着 TArray&lt;UBota_ItemSpec&gt; InventoryContainer，并标记了 Replicated。</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_InventoryComponent::GetLifetimeReplicatedProps</span><span class="hljs-params">(TArray&lt;<span class="hljs-keyword">class</span> FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>{Super::<span class="hljs-built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);<span class="hljs-built_in">DOREPLIFETIME</span>(ThisClass, InventoryContainer);}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">UBota_InventoryComponent::ReplicateSubobjects</span><span class="hljs-params">(UActorChannel* Channel, FOutBunch* Bunch, FReplicationFlags* RepFlags)</span></span><span class="hljs-function"></span>{<span class="hljs-type">bool</span> bWroteSomething = Super::<span class="hljs-built_in">ReplicateSubobjects</span>(Channel, Bunch, RepFlags);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Item : InventoryContainer-&gt;Items){bWroteSomething |= Channel-&gt;<span class="hljs-built_in">ReplicateSubobject</span>(Item, *Bunch, *RepFlags);}<span class="hljs-keyword">return</span> bWroteSomething;}</code></pre><p>直到这里，我们算是实现了自定义的 UObject 的网络复制。但我目前遇到的问题不清楚是故意设计还是引擎问题，就是 <code>UBota_ItemSpec</code> 定义蓝图派生类，在蓝图中定义的数据成员就算启用了网络复制也无法进行网络复制，换句话说，<code>UBota_ItemSpec</code> 的派生体系只能在 C++ 端完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;尽管 C++ 本身视 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;struct&lt;/code&gt; 都为类类型，区别只在默认访问修饰符（class 默认为 private，struct 默认为 public）。但在虚幻引擎中却有所不同，&lt;code&gt;UObject&lt;/co</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="ItemSystem" scheme="http://www.yerha.top/tags/ItemSystem/"/>
    
    <category term="NetReplication" scheme="http://www.yerha.top/tags/NetReplication/"/>
    
  </entry>
  
  <entry>
    <title>实现昼夜变化</title>
    <link href="http://www.yerha.top/2024/04/07/implement-day-night-functionality/"/>
    <id>http://www.yerha.top/2024/04/07/implement-day-night-functionality/</id>
    <published>2024-04-07T07:47:36.000Z</published>
    <updated>2024-04-08T13:00:06.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/04/07/implement-day-night-functionality/overview.png"></p><p>时间系统是游戏世界（尤其是开放类游戏）常见到的机制，除了为模拟现实世界的情况外，也经常作为衬托游戏剧情发展的因素。将它们封装起来并提供可配置的简单参数，有一定的必要性。本博文主要讨论以下几点：</p><ul><li>如何自定义日出和日落时间，在此期间可以看到日光，不在此期间时看到月亮；</li><li>如何将天空有关的组件进行封装，可以方便地迁移到不同关卡或项目中；</li></ul><h2 id="天体相关的组件"><a href="#天体相关的组件" class="headerlink" title="天体相关的组件"></a>天体相关的组件</h2><p>打开一个基础关卡，在大纲视图中通常可以看到一些组成天体的组件：</p><ul><li>Directional Light：方向光源，在这里指示着太阳的方向。这种光源在参与光源计算时只会使用其旋转信息，其位置不会影响到光源的计算。在虚幻引擎中，任意时刻都要保证至多一个方向光源可见。本例中在白天中仅 <code>SunDirectionalLight</code> 可见，黑色中仅 <code>MoonDirectionalLight</code> 可见。</li><li>Sky Atmosphere：模拟大气层的组件，会影响光源的散射，使画面更加逼真。</li><li>Sky Light：会将场景中较远部分的物体作为光源。在本例中，启用了 <code>Real Time Capture</code> 选项。</li><li>Exponential Height Fog：基于高度的云雾效果，可以设置密度值来增强或削弱光源的雾化效果。</li><li>Post Process：后处理体积，位于体积内的像素会进行额外的处理，类似于滤镜功能。在本例中，将其体积设置为了 <code>Infinite</code>，并将其 <code>Min EV100</code> 和 <code>Max EV100</code> 都设置为了 0.5，设置为相同的值会使光源立即变化，而不会有自动曝光的处理过程。</li><li>Volumetric Cloud：体积云组件，将介质类材质覆盖在天体上。本例中使用该组件搭配自定义的材质实现云朵。</li><li>Static Mesh：静态网格组件。在本例中使用了引擎  <code>/Content/EngineSky/SM_SkySphere</code> 网格资产表示天体球，将其统一缩放值调整的很大（10000 倍），尽可能确保玩家自由视角下都不会离开该天体。</li></ul><p>在本例中，以上组件都定义了在一个 Actor 中，这样就可以确保在不同的关卡中放置该 Actor 就可以立即生成可配置的天体系统。</p><p><img src="/2024/04/07/implement-day-night-functionality/actor_that_store_sky_planet_components.png"></p><h2 id="昼夜变化的实现"><a href="#昼夜变化的实现" class="headerlink" title="昼夜变化的实现"></a>昼夜变化的实现</h2><p>在本例中日光和月光分别由控制 SunDirectionalLight 和 MoonDirectionalLight 的 <code>Pitch</code> 旋转信息来实现的。具体来说引入了三个浮点变量来抽象化它们的旋转参数：TimeOfDay 代表当前的时间，DawnTime 代表日出时间，DuskTime 代表日落时间。如果 TimeOfDay 的值落在了 [DawnTime, DuskTime] 区间时代表白天，应当仅 SunDirectionalLight 可见并且将其映射到 [-180, 0] 旋转度数区间上。不在该区间时就代表黑夜，我们需要将日落时间作为起点，然后到下一个日出时间作为终点，映射月光的旋转度数区间上，因此对于零点之前的时间可以直接使用 TimeOfDay 值，而对于零点之后的值需要进行偏移 <code>DuskTime + (DuskTime 到 24 点的距离) + TimeOfDay = DuskTime + (24 - DuskTime) + TimeOfDay = 24 + TimeOfDay</code>。对于这两个方向光源的旋转设置逻辑如下所示：</p><p><img src="/2024/04/07/implement-day-night-functionality/set_rotation_of_directional_lights_based_on_time.png"></p><p>在前言中还提到了在任何时刻都应该保证只有一个方向光源，因此需要根据 TimeOfDay 是否落在表示白天的区间来设置两个 DirectionalLight 的可见性：</p><p><img src="/2024/04/07/implement-day-night-functionality/set_directional_lights_visibility.png"></p><p>在材质方面，我们需要为天体球制作一个无灯光的着色模型，并在高级选项中勾选 <code>Is Sky</code>。首先我们至少要输出 <code>SkyAtmosphereViewLuminance</code> 和 <code>SkyAtmosphereLightDiskLumiance[0]</code> 相加后的结果，前者表示光源与 大气光 相互作用后天空的最终亮度，而后者表示应用了大气透射率运算后的太阳亮度，相加后就得到了在大气内可观察到的天空大气效果。对于白天来说并不需要专门的太阳纹理来展示，因为玩家也只会看到白色的发光球体。而在夜晚，我们需要一个月亮纹理来替换掉表示太阳的区域，幸运的是虚幻引擎提供了 <code>SkyAtmosphereLightDirection</code> 和 <code>SkyAtmosphereImage</code> 来让我们在太阳的位置处显示一张纹理，再额外添加一些如 <code>Tint</code>、<code>Scale</code>、<code>Brightness</code> 等参数供设计师调整月亮纹理，最终有关于月亮纹理输出的逻辑如下：</p><p><img src="/2024/04/07/implement-day-night-functionality/moon_material_expression.png"></p><p>除了月光以外，夜空中也可以加入群星纹理。可以使用 <code>TimeWithSpeedVariable</code> 和 <code>Panner</code> 来平移纹理来实现星星的移动，我在这里还引入了噪波纹理来实现群星“若隐若现”的效果，最后根据顶点法向量 z 轴在世界空间中的值来限定星星出现的区域，越靠近地平线则越不会出现星星，最终群星的输出的逻辑如下：</p><p><img src="/2024/04/07/implement-day-night-functionality/stars_material_expression.png"></p><p>将上述得到的输出节点相加在一起连接到材质输出节点的 <code>Emissive Color</code> 节点即可。在这里有一个参数称为 <code>IsNightTime</code>会在蓝图中可以创建一个动态材质实例在夜晚时设置为大于 0 的值，在白天设置为 0，这样就可以确保月亮和群星仅在夜晚可见。</p><p><img src="/2024/04/07/implement-day-night-functionality/sky_sphere_final_ouput.png"><br><img src="/2024/04/07/implement-day-night-functionality/set_up_is_night_time_parameter.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/04/07/implement-day-night-functionality/overview.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;时间系统是游戏世界（尤其是开放类游戏）常见到的机制，除了为模拟现实世界的情况外，也经常作为衬托游戏剧情发展的因素。将它</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="SkyWeather" scheme="http://www.yerha.top/tags/SkyWeather/"/>
    
    <category term="VolumetricClouds" scheme="http://www.yerha.top/tags/VolumetricClouds/"/>
    
  </entry>
  
  <entry>
    <title>如何用 InputAction 来触发 GameplayAbility 的激活</title>
    <link href="http://www.yerha.top/2024/04/07/binding-IA-to-GA/"/>
    <id>http://www.yerha.top/2024/04/07/binding-IA-to-GA/</id>
    <published>2024-04-07T01:49:27.000Z</published>
    <updated>2024-04-07T03:48:04.302Z</updated>
    
    <content type="html"><![CDATA[<p>GAS 作为管理技能和属性相关的灵活插件，使得开发制作角色扮演游戏、多人在线战术竞技游戏不再那么繁琐。另一方面，虚幻引擎将增强输入系统作为了默认输入组件，这不仅使得按下、按下并按住等常见功能逻辑作为了内置功能，还引入了上下文和优先级机制，使得我们可以将同一个按键在不同的上下文中发挥不同的效果。</p><p>如果有机会通过增强输入系统中的输入动作映射到 GAS 的技能激活，那么就可以以很优雅的方式在不同上下文中激活不同的技能。例如鼠标左键在未装备武器时激活挥拳技能、装备枪械时变为开火技能；空格键可以先作为跳跃技能的触发按钮，后期又可以灵活地替换成翻滚技能的触发按钮。本博文将讨论以下几点内容：</p><ul><li>何时应该赋予角色技能，以及输入事件的绑定；</li><li>如何保证所有技能任务都正确工作，尤其是等待输入 ID 按下和释放的技能任务；</li><li>有些技能不需要按键来触发，怎么维护需要按键和不需要按键的技能。</li></ul><h2 id="赋予角色技能的时机"><a href="#赋予角色技能的时机" class="headerlink" title="赋予角色技能的时机"></a>赋予角色技能的时机</h2><p>根据个人过去游戏开发的经历，赋予角色技能的时机通常分为两种情况：1. 所有的技能在初始化技能系统组件后，一次性全部获得；2. 部分技能在初始化技能系统组件后获得，剩余技能在游戏期间中逐渐获得。通俗点儿说，前者更像是玩家已经化身为 “大师”，只是需要根据游戏的进程来明白自己并非 “凡夫俗子”；后者通常像是一件物品对玩家说：“想弄懂我就装备我吧”，例如只有装备枪械时才会得到开火和换子弹的技能，卸下装备时就失去了这两个技能。</p><p>从开发的角度来说，一次性赋予的方式最为直接，但有着十分苛刻的技能激活的判断条件，要确保玩家激活了预期的技能。而部分赋予的方式间接引入了上下文的概念，只有满足特定条件和身处特定环境时才能得到激活技能的机会，在 GAS 框架下还有机会为技能提供 <code>SourceObject</code> 信息，从而在技能内部获取物品的信息，比如说开火技能可以找到武器网格中枪口 <code>Socket</code>、开火间隔的信息。但部分赋予的方式还可能会引发频繁地技能赋予和取消，比如游戏为玩家提供了 <code>Q</code> 键或鼠标滚轮来切换武器的机制，而包括在我内的一些玩家非常喜欢频繁切换它们，结果上是玩家频繁地获取和失去相同的技能。最后是部分赋予的方式还会使得 <code>InputID</code> 难以维护，该值在赋予技能的时候显式地提供，且通常是被前言中提到的技能任务有关，而我们更愿意使设计师可以用到的节点都能正常工作。</p><p>从上面的描述中看来，一次性赋予的方式会使得生活更加容易一些，我们需要做好就是确保判断技能激活的条件，而虚幻引擎增强输入系统的上下文机制可以辅助我们解决这个问题。当玩家获得装备时（通常在 <code>BeginPlay</code>），将玩家的输入上下文中增加开火上下文，在卸下时去掉开火上下文（通常在 <code>EndPlay</code>）。在我的实现版本中，我将技能定义为了结构体，角色类中有存储该结构体的数组，然后在初始化技能系统函数中赋予玩家这些能力：</p><pre><code class="hljs CPP"><span class="hljs-built_in">USTRUCT</span>(BlueprintType)<span class="hljs-keyword">struct</span> <span class="hljs-title class_">FBota_AbilityInputActionBinding</span>{<span class="hljs-built_in">GENERATED_BODY</span>()<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)TSubclassOf&lt;UGameplayAbility&gt; AbilityClass;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)TObjectPtr&lt;UInputAction&gt; InputAction;};<span class="hljs-comment">// ABota_Character 中有 TArray&lt;FBota_AbilityInputActionBinding&gt; AbilityBindings</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::OnInitAbilityActorInfo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetBotaAbilitySystemComponent</span>();<span class="hljs-keyword">if</span> (!ASC)<span class="hljs-keyword">return</span>;AActor* InOwner = <span class="hljs-literal">nullptr</span>, *InAvatar = <span class="hljs-literal">nullptr</span>;<span class="hljs-built_in">GetAbilitySystemAvatarAndOwner</span>(InOwner, InAvatar);ASC-&gt;<span class="hljs-built_in">InitAbilityActorInfo</span>(InOwner, InAvatar);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">HasAuthority</span>())<span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Binding : AbilityBindings){<span class="hljs-keyword">if</span>(Binding.AbilityClass)ASC-&gt;<span class="hljs-built_in">GiveAbilityAndAssignInputID</span>(<span class="hljs-built_in">FGameplayAbilitySpec</span>(Binding.AbilityClass));}}</code></pre><p>在代码中可以看到，在服务器端使用了自定义的函数 <code>GiveAbilityAndAssignInputID</code>，它在 <code>GiveAbility</code> 的基础上还会为技能提供一个有效的 <code>InputID</code>。它的实现如下：</p><pre><code class="hljs CPP"><span class="hljs-comment">// UBota_AbilitySystemComponent 中有 int32 ValidInputID = 0</span><span class="hljs-function">FGameplayAbilitySpecHandle <span class="hljs-title">UBota_AbilitySystemComponent::GiveAbilityAndAssignInputID</span><span class="hljs-params">(<span class="hljs-type">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">auto</span> TempAbilitySpec = AbilitySpec;TempAbilitySpec.InputID = ValidInputID;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; SpecHandle = <span class="hljs-built_in">GiveAbility</span>(TempAbilitySpec);<span class="hljs-keyword">if</span> (SpecHandle.<span class="hljs-built_in">IsValid</span>()){ValidInputID++;}<span class="hljs-keyword">return</span> SpecHandle;}</code></pre><h2 id="输入的绑定"><a href="#输入的绑定" class="headerlink" title="输入的绑定"></a>输入的绑定</h2><p>在上一节定义的结构体中，可以看到 <code>TObjectPtr&lt;UInputAction&gt; InputAction</code> 成员，这是设计师可以为技能映射按键的位置。这个 <code>InputAction</code> 可以加入到角色默认的 <code>InputMappingContext</code> 中，这样玩家一开始就可以通过按下对应的按键来激活技能，也可以加入到其他的 <code>InputMappingContext</code> 中然后动态地添加角色的输入系统中。在这种的实现机制中，<code>AbilityBindings</code> 在运行时保持值不变，因此可以很安全地遍历数组。下面的代码演示了如何将 <code>InputAction</code> 进行绑定并且在回调函数中找到对应的技能并激活：</p><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::SetupPlayerInputComponent</span><span class="hljs-params">(UInputComponent* PlayerInputComponent)</span></span><span class="hljs-function"></span>{Super::<span class="hljs-built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; EIC = <span class="hljs-built_in">CastChecked</span>&lt;UEnhancedInputComponent&gt;(PlayerInputComponent);<span class="hljs-keyword">if</span> (!EIC)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Binding : AbilityBindings){<span class="hljs-keyword">if</span> (!Binding.InputAction)<span class="hljs-keyword">continue</span>;EIC-&gt;<span class="hljs-built_in">BindAction</span>(Binding.InputAction, ETriggerEvent::Started, <span class="hljs-keyword">this</span>, &amp;ThisClass::InputActionPressed, Binding.AbilityClass);EIC-&gt;<span class="hljs-built_in">BindAction</span>(Binding.InputAction, ETriggerEvent::Completed, <span class="hljs-keyword">this</span>, &amp;ThisClass::InputActionReleased, Binding.AbilityClass);}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::InputActionPressed</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityClass)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (!InAbilityClass)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetBotaAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">FindAbilityByClassAndPressedInputID</span>(InAbilityClass);}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::InputActionReleased</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityClass)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (!InAbilityClass)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetBotaAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">FindAbilityByClassAndRelesedInputID</span>(InAbilityClass);}}</code></pre><p>虚幻引擎的委托绑定函数允许我们额外传递函数形参，所以在上面的代码中在回调函数中将 <code>InputAction</code> 映射的 <code>AbilityClass</code> 传递了过来，然后调用了 <code>AbilitySystemComponent</code> 中自定义的函数 <code>FindAbilityByClassAndPressedInputID</code> 和 <code>FindAbilityByClassAndRelesedInputID</code> 来实现技能的触发。</p><h2 id="寻找技能实例然后激活它"><a href="#寻找技能实例然后激活它" class="headerlink" title="寻找技能实例然后激活它"></a>寻找技能实例然后激活它</h2><p>在 <code>InputAction</code> 的回调函数中调用了 <code>AbilitySystemComponent</code> 的函数 <code>FindAbilityByClassAndPressedInputID</code> 和 <code>FindAbilityByClassAndRelesedInputID</code>，我采取的实现是结合了 <code>TryActivateAbilityByClass</code> 、<code>AbilityLocalInputPressed</code> 和 <code>AbilityLocalInputReleased</code>。因为这些函数会在调用时各自遍历一次可激活技能数组，所以修改为了只遍历一次：</p><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_AbilitySystemComponent::FindAbilityByClassAndPressedInputID</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate)</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">ABILITYLIST_SCOPE_LOCK</span>();<span class="hljs-type">const</span> UGameplayAbility* <span class="hljs-type">const</span> InAbilityCDO = InAbilityToActivate.<span class="hljs-built_in">GetDefaultObject</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Spec : ActivatableAbilities.Items){<span class="hljs-keyword">if</span> (Spec.Ability == InAbilityCDO){<span class="hljs-keyword">if</span> (Spec.Ability){Spec.InputPressed = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (Spec.<span class="hljs-built_in">IsActive</span>()){<span class="hljs-keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; <span class="hljs-built_in">IsOwnerActorAuthoritative</span>() == <span class="hljs-literal">false</span>){<span class="hljs-built_in">ServerSetInputPressed</span>(Spec.Handle);}<span class="hljs-built_in">AbilitySpecInputPressed</span>(Spec);<span class="hljs-built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, Spec.ActivationInfo.<span class="hljs-built_in">GetActivationPredictionKey</span>());}<span class="hljs-keyword">else</span>{<span class="hljs-built_in">TryActivateAbility</span>(Spec.Handle);}}}}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_AbilitySystemComponent::FindAbilityByClassAndRelesedInputID</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate)</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">ABILITYLIST_SCOPE_LOCK</span>();<span class="hljs-type">const</span> UGameplayAbility* <span class="hljs-type">const</span> InAbilityCDO = InAbilityToActivate.<span class="hljs-built_in">GetDefaultObject</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Spec : ActivatableAbilities.Items){<span class="hljs-keyword">if</span> (Spec.Ability == InAbilityCDO){Spec.InputPressed = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (Spec.Ability &amp;&amp; Spec.<span class="hljs-built_in">IsActive</span>()){<span class="hljs-keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; <span class="hljs-built_in">IsOwnerActorAuthoritative</span>() == <span class="hljs-literal">false</span>){<span class="hljs-built_in">ServerSetInputReleased</span>(Spec.Handle);}<span class="hljs-built_in">AbilitySpecInputReleased</span>(Spec);<span class="hljs-built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, Spec.ActivationInfo.<span class="hljs-built_in">GetActivationPredictionKey</span>());}}}}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GAS 作为管理技能和属性相关的灵活插件，使得开发制作角色扮演游戏、多人在线战术竞技游戏不再那么繁琐。另一方面，虚幻引擎将增强输入系统作为了默认输入组件，这不仅使得按下、按下并按住等常见功能逻辑作为了内置功能，还引入了上下文和优先级机制，使得我们可以将同一个按键在不同的上下</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="GAS" scheme="http://www.yerha.top/tags/GAS/"/>
    
    <category term="EnhancedInputSystem" scheme="http://www.yerha.top/tags/EnhancedInputSystem/"/>
    
  </entry>
  
  <entry>
    <title>进阶运动动画的实现</title>
    <link href="http://www.yerha.top/2024/03/24/Advanced-Locomotion-Animation-Logic/"/>
    <id>http://www.yerha.top/2024/03/24/Advanced-Locomotion-Animation-Logic/</id>
    <published>2024-03-24T02:07:38.000Z</published>
    <updated>2024-03-25T03:54:45.915Z</updated>
    
    <content type="html"><![CDATA[<p>自虚幻引擎5发布以来，Epic 官方提供了很多实用的工具来处理动画资产，在初学者项目 Lyra 中不仅可以看到这些工具的具体应用，还提供了一个进阶版本的动画逻辑解决方案（相较于第三人称射击模板附带的动画蓝图）。本博文主要讨论这套方案的以下几个要点：</p><ul><li>如何修改动画序列数据以满足该解决方案的资产要求；</li><li>如何减轻游戏主线程的负担，让动画逻辑不成为性能瓶颈；</li><li>如何在运行时灵活地替换部分动画，例如玩家装备武器时，将无持械的动画替换为该武器对应的动画。</li></ul><p>为了使这套解决方案可以正确工作，以及方便动画资产的处理，需要项目启用<code>Animation Locomotion Library</code>、<code>Animation Warping</code>、<code>Animation Modifier Library</code>插件。本解决方案对应的角色旋转设置如下：</p><pre><code class="hljs CPP"><span class="hljs-comment">// 角色的朝向跟随 ControllRotation</span>bUseControllerRotationYaw = <span class="hljs-literal">true</span>;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; CharMovement = <span class="hljs-built_in">GetCharacterMovement</span>();CharMovement-&gt;bOrientRotationToMovement = <span class="hljs-literal">false</span>;</code></pre><h2 id="动画序列资产"><a href="#动画序列资产" class="headerlink" title="动画序列资产"></a>动画序列资产</h2><p>在 Lyra 中，角色的地面运动主要分为站立步行（Walk）、站立奔跑（Jog）和蹲下行走（Crouch）三种姿态，每种姿态都有空闲（Idle）和前后左右的开始（Start）、运动（Cycle）、结束（Stop）、枢轴（Pivot）动画。在开始、结束和枢轴动画中要求资产有名为 Distance 的曲线，标志着在当前帧在动画里移动的距离。这会在运行时通过计算真实运动的距离来调整序列的播放进度，比如角色停下需要往前走 100 厘米才能将速度大小降为零，在动画蓝图中需要找到 100 厘米对应的帧是多少然后从那里开始播放，还会在每帧根据移动距离随时调整播放进度。枢轴主要处理在运动状态下加速度与速度方向角度大于九十度时的情况，例如在往前走的状态中，玩家输入了往后走时，需要表现出先成往前跑的姿势停下来，然后再开始往后跑的姿势。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/showcase_distance_curve.png"></p><p>在制作这样的曲线前，需要先定义一个<code>Curve Compression Settings</code>，并设置编码方式为 Uniform Indexable，这是虚幻引擎在文档中的要求，以确保可以在运行时访问到曲线信息。具体是在内容浏览器中按下鼠标右键，依次选择 Animation / Advanced / Curve Compression Settings，双击打开新资产为 Codec 设置 Uniform Indexable。所有需要使用曲线信息的动画序列里，Asset Details / Compression / Curve Compression Settings 赋为新建的压缩设置。对于多个动画序列资产，可以选中它们然后右键 Asset Actions / Edit Selection in Property Matrix，以实现批量修改。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/curve_compression_settings_in_property_matrix.png"></p><p>制作这样的曲线，并不需要我们手动绘制。在动画序列编辑器中 Window 菜单下有一个 Animation Data Modifier 选项，点击它就会出现一个窗口，在这个窗口下可以借助一系列的修改器生成符合满足需求的曲线、轨道（Track）和通知（Notify）。其中就有一个<code>DistanceCurveModifier</code>，它就可以自动生成我们需要的曲线。在 Asset Details 中勾选<code>Enable Root Motion</code>选项后就可以右键应用修改器了。同样如果多个序列都需要这样的设置时，可以先用上文提到的 Property Matrix 来勾选<code>Enable Root Motion</code>后，对这些右键选择 Animation Modifier(s) / Add New Modifiers 来添加和应用修改器。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/distance_curve_modifier_UI.png"></p><p>除了创建 Distance 曲线，推荐进一步应用<code>SyncMarkerAnimModifier</code>，它会创建一个<code>FootSyncMarkers</code>轨道并在里面创建若干个标记为 L 和 R 的通知，后期在动画蓝图中选择同步组后，就可以实现不同动画之间过渡时能匹配姿势，产生连贯地动画。</p><p>除了地面运动外，还有一些跳跃有关的动画，分别是跳跃开始（JumpStart）、跳跃开始循环（JumpStartLoop）、跳跃到极点（JumpApex）、下落循环（FallLoop）以及下落着陆（FallLand）。可以为这些资产加上 <code>DistableFootIK</code>的曲线，确保腿部不会尝试寻找可以落脚的位置。而对于下落着陆动画中还需要添加一个<code>GroundDistance</code>的曲线，表示每一帧到地面的距离，在实际下落时可以计算到地面的距离值来调整播放进度。这同样是通过<code>DistanceCurveModifier</code>实现的，在配置中设置轴（Axis）为<code>Z</code>即可。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/ground_distance_in_fall_land_sequence.png"></p><h2 id="动画蓝图与动画层"><a href="#动画蓝图与动画层" class="headerlink" title="动画蓝图与动画层"></a>动画蓝图与动画层</h2><p>与本博文讨论话题有关的动画相关类有三个，它们分别是：</p><ul><li><code>ABP_Mannequin_Base</code>：派生自 AnimInstance，作为角色骨骼网格组件的动画蓝图类。获取和计算 AnimGraph 使用的变量。而 AnimGraph 作为一个总的动画框架，包含运动（Locomotion）状态机、相加姿势（Additive Pose）融合、根旋转（Root Rotate）以及一些蒙太奇槽位的连接。<strong>但这里并没有具体的动画姿势</strong>，所有需要动画姿势的位置都连接了动画层接口（AnimLayersInterface）中的一个动画层。</li><li><code>ALI_ItemAnimLayers</code>：作为一个动画层接口，里面定义了一系列姿势输入与输出的动画层。可以这么思考，动画层相当于接口类中的虚函数，但必须要返回一个姿势，是否有输入姿势或其他变量则作为可选项。继承了这个接口的动画蓝图类可以使用动画层（类似调用）作为节点的输入。也可以实现接口，在运行时动态的链接（Link）到使用动画层的动画蓝图。在本例中<code>ABP_ItemAnimLayersBase</code>实现了所有的动画层，输出姿势给<code>ABP_Mannequin_Base</code>使用，后者使用动画层作为自己 AnimGraph 中一些节点的输入。</li><li><code>ABP_ItemAnimLayersBase</code>：派生自 AnimInstance。作为 ALI_ItemAnimLayers 的一个实现类，对于接口中的每个动画层都提供了有效的输出。它作为一种基类存在，将具体的姿势暴露为一个个变量，而派生类只需要为这些变量赋值即可。例如，<code>ABP_PistolAnimLayers</code>派生类只是给变量赋值，提供了角色装备手枪时的站立、运动、跳跃等动画。</li></ul><p>Lyra 并不是一个专注于射击的游戏，它支持使用<code>GameFeature</code>来增加更多的游戏玩法，官方示例中除了死斗、占点模式外，还有一个玩法完全不一样的炸弹人（类似QQ堂）模式，也允许开发者增加更多的玩法。因此，<code>ABP_Mannequin_Base</code>动画蓝图中获取与计算的变量较为基础，一些与射击模式有关的变量获取与计算工作留给了<code>ABP_ItemAnimLayersBase</code>来完成，后者与射击模式有关。如果游戏项目专门是射击玩法的话，可以考虑将<code>ABP_ItemAnimLayersBase</code>中计算变量的逻辑迁移到<code>ABP_Mannequin_Base</code>，使前者可以专注于生成姿势的逻辑。</p><hr><p>打开动画蓝图时，会发现 EventGraph 没有任何逻辑在执行。原先会在<code>BlueprintUpdateAnimation</code>中进行的逻辑，现在在<code>BlueprintThreadSafeUpdateAnimation</code>完成了，后者在逻辑中会利用多线程来分摊数据的计算，减轻了游戏主线程的负担。在这个函数中需要注意以下三点：</p><ul><li>获取外部函数和变量的值使用<code>PropertyAccess</code>节点来访问。据虚幻引擎官方介绍，该节点会在 Update 函数执行之前会对相关的变量进行缓存，读取缓存时的数据，这样一定程度上避免了数据竞争的问题，总之被官方定义为是线程安全的访问形式。</li><li>在该函数中执行的函数要勾选 Advanced / Thread Safe，线程安全的函数访问外部数据时只能使用<code>PropertyAccess</code>进行。</li><li>如果想定义可以在<code>PropertyAccess</code>节点中选择的函数，它必须是线程安全的、没有形参，返回值的名称必须是<code>ReturnValue</code>。对返回值的名称要求暂不清楚这是刻意的行为还是软件错误，如果不是这个名称则无法调用。在本例中<code>ABP_Mannequin_Base</code>定义了返回<code>UCharacterMovementComponent</code>实例的函数，而<code>ABP_ItemAnimLayersBase</code>也需要使用这个实例，但它只能使用<code>PropertyAccess</code>的形式来调用<code>ABP_Mannequin_Base</code>定义的函数。</li></ul><p>本节接下来的内容是谈论对一些变量的理解，如果不需要可以跳到下一节。</p><hr><p>在 Lyra 的实现中并不会有空闲、步行到奔跑的渐变过渡，或者说并没有一个混合空间（BlendSpace）来处理速度从 0 到 Max Walk Speed 的过渡，而是根据用户的输入直接在一帧内直接切换到另一种速度的姿态。这是基于游戏玩法设计的需求，角色的运动组件中加速度大小的增量被设置为了 2048 cm，这意味着步行的动画还没有播放几帧就已经完全在播放奔跑的了。而步行的姿态只会在一个名为<code>GameplayTag_is_ADS</code>布尔变量为 true 时播放，玩家进行精准瞄准（例如按下鼠标右键）或者静步走时会获得对应类似的标签，角色类会检查是否获得了这个标签从而改变 <code>GameplayTag_is_ADS</code>的值。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/cycle_sequence_player_select_anim_sequence.png"></p><hr><p>这里也没有四个方向运动的渐变过渡，而是计算局部速度方向角度值来设置一个 <code>AnimEnum_CardinalDirection</code>类型的枚举变量 <code>LocalVelocityDirectionNoOffset</code>，里面枚举值分别是前（Forward）、后（Backward）、左（Left）和右（Right）。在设置该枚举变量的函数<code>SelectCardinalDirectionFromAngle</code>可以发现，如果玩家持续向前或向后运动的时候，将会更难切换到向左或向右的动画，这减少了频繁切换动画的情况发生。而在混合空间中很难（好像不可能）在运行时调整各个采样的坐标。而为了让姿势更加自然，输出的姿势引脚接入了 <code>Orientation Warping</code> 节点，它会根据局部速度方向角度值来旋转角色的朝向。在浏览<code>SelectCardinalDirectionFromAngle</code>函数时，需要注意的是：1. 形参 Angle 是[-180,180]的值，正面角度是 0，反面是 -180 或 180，右面是 90，左面是 -90；2. 在判断正反面使用的是 Angle 的<strong>绝对值</strong>，但判断左右面的时候用的是 Angle <strong>原值</strong>，在复现时这里有可能会误用绝对值版本。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/select_cardinal_direction_focus_on_enlarge_dead_zone.png"><br><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/cycle_output_connects_orientation_warping.png"></p><hr><p>在<code>UpdateCharacterStateData</code>函数中可以看到，角色在竖直方向（z）的速度方向是正还是反来区分是跳跃还是下落的状态。紧接着在<code>UpdateJumpFallData</code>函数中可以看到在跳跃状态时，会以竖直方向速度大小的相反数除以重力Z值（重力值是负值，表示竖直向下的方向），作为从跳跃开始循环到跳跃极点两个动画状态之间的转换条件。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/update_jump_fall_data.png"><br><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/jump_start_loop_to_jump_apex.png"></p><hr><p>在<code>UpdateRootYawOffset</code>函数中可以看到<code>RootYawOffsetMode</code>变量的更新方法，这个变量是<code>AnimEnum_RootYawOffsetMode</code>枚举类型，一共有<code>Accmulate</code>、<code>Hold</code>和<code>BlendOut</code>三个枚举值。在外部修改这个变量时也只会是<code>Accumulate</code>和<code>Hold</code>之间的一个，前者会累加角色旋转体（Rotator）的 Yaw 值到<code>RootYawOffset</code>值上，后者保持<code>RootYawOffset</code>当前值。无论是哪一种选项，最后都会修改成<code>BlendOut</code>值，意味着下一帧如果没有修改该枚举变量的话，它会从当前的值线性插值到 0。在实际运用中，会在休闲状态（Idle）中锁在<code>Accumulate</code>值，这样旋转摄影机可以看到角色的各个面，因为根骨骼正在与摄影机在 Yaw 轴上进行相反的旋转。在开始状态（Start）时锁到<code>Hold</code>值，以当时的旋转值播放开始姿势。在运动状态（Cycle）中没有锁住该枚举变量的值，因此根骨骼会慢慢插值回到摄影机看向的方向。在停止状态（Stop）开始锁为<code>Accumulate</code>值，这样停止动画期间就可以旋转视角而不会影响角色旋转了。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-update_root_yaw_offset.png"></p><hr><p><code>LinkedLayerChanged</code>和<code>LastLinkedLayer</code>两个变量与运行时是否链接了新动画层有关，它们的更新时机是在 LocomotionSM 状态机的<code>OnUpdate</code>绑定函数中（单击状态机后在细节面板中可以找到），在内部会发现一个<code>StartLayerNode</code>的动画节点引用，在那里会检查是否与之前存储的动画层引用相同，进而触发修改逻辑。关键在于这个引用节点的创建方式，实际上它指向的是 LocomotionSM / Start 中的 FullBody_StartState，在它的细节面板中可以看到<code>Tag</code>条目，为它指定一个名字就可以在动画蓝图中引用它了。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-on_locomotionSM_update.png"></p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-fullbody_startstate_tag.png"></p><hr><p>最后需要了解的是，动画蓝图中大量使用了<code>Sequence Player</code>和<code>Sequence Evaluator</code>节点，可简单地理解为前者可以播放一个动画序列，后者在前者基础上可以更改播放起始点。为了实现动态地的更换播放的资产和调整播放时间，因此它们在细节面板中<code>Sequence</code>和<code>Explicit Time</code>（仅限 Evaluator）都会更改成<code>Dynamic</code>形式。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-sequence_player_set_dynamic.png"></p><p>对于这两个播放节点会绑定<code>On Become Relevant</code>和<code>On Update</code>函数：前者代表这个序列开始贡献姿势的第一帧，也就是权重值不再是 0% 了；后者就是每帧都会调用的函数。在函数内部通常对<code>Node</code>形参调用<code>Convert to Sequence Player</code> 或 <code>Convert to Sequence Evaluator</code>，从而进一步设置播放的 Sequence 以及设置 Explicit Time（仅限 Evaluator）。在上文中讲述过开始、停止和枢轴动画中加入了 Distance 曲线。对于它们来说我们可以在<code>Sequence Evaluator</code>的<code>On Update</code>函数中调用<code>Advance Time by Distance Matching</code>节点，将当前帧与上一帧角色移动的位置差作为参数就可以转换为播放的帧起始点。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-Advance_Time_by_Distance_Matching.png"></p><p>对于停止动画会使用<code>Predict Ground Movement Stop Location</code>来计算出停止的位置出，得到向量长度后可以使用<code>Distance Match to Target</code>节点来调整<code>Explicit Time</code>。在 Lyra 中计算距离值的逻辑封装为了<code>Get Predicted Stop Distance</code>函数。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-get_predicted_stop_distance.png"></p><h2 id="在运行时链接动画层"><a href="#在运行时链接动画层" class="headerlink" title="在运行时链接动画层"></a>在运行时链接动画层</h2><p>在 Lyra 解决方案中，角色类使用的动画蓝图类是<code>ABP_Mannequin_Base</code>，但从上一节的描述中已经知道这个蓝图类中没有具体的动画资产，所以直接使用只会得到 T-Pose。为了链接到实现了动画层的动画蓝图，可以使用下面的函数来动态的链接和取消链接动画蓝图：</p><pre><code class="hljs CPP"><span class="hljs-comment">// 参数为实现了动画层的动画蓝图类</span><span class="hljs-built_in">GetMesh</span>()-&gt;<span class="hljs-built_in">LinkAnimClassLayers</span>(); <span class="hljs-built_in">GetMesh</span>()-&gt;<span class="hljs-built_in">UnlinkAnimClassLayers</span>();</code></pre><p>但直接调用这个函数并不会进行网络同步，需要定义一个<code>NetMulticast</code>函数来确保所有客户端中都可以看到这个链接函数。以下是一个示例，如果第二个参数为 true 就调用 Link 函数，否则就调用 Unlink 函数：</p><pre><code class="hljs CPP"><span class="hljs-built_in">UFUNCTION</span>(NetMulticast, Reliable)<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Multicast_SetMeshCompAnimLayers</span><span class="hljs-params">(TSubclassOf&lt;UAnimInstance&gt; InClass, <span class="hljs-type">bool</span> bLinkIt = <span class="hljs-literal">true</span>)</span></span>;</code></pre><p>可装备道具在设计时可以加入一个 TSubclassOf<uaniminstance> 类型的变量，要求设计师指定一个实现了动画层的动画蓝图类，在运行时调用<code>Multicast_SetMeshCompAnimLayers</code>函数以便于动态地调整姿势。</uaniminstance></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自虚幻引擎5发布以来，Epic 官方提供了很多实用的工具来处理动画资产，在初学者项目 Lyra 中不仅可以看到这些工具的具体应用，还提供了一个进阶版本的动画逻辑解决方案（相较于第三人称射击模板附带的动画蓝图）。本博文主要讨论这套方案的以下几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="Animation" scheme="http://www.yerha.top/tags/Animation/"/>
    
    <category term="Lyra" scheme="http://www.yerha.top/tags/Lyra/"/>
    
  </entry>
  
  <entry>
    <title>如何将建造功能作为一种技能</title>
    <link href="http://www.yerha.top/2024/03/10/Implement_Building_System_With_GAS/"/>
    <id>http://www.yerha.top/2024/03/10/Implement_Building_System_With_GAS/</id>
    <published>2024-03-10T13:38:48.000Z</published>
    <updated>2024-03-24T02:05:12.942Z</updated>
    
    <content type="html"><![CDATA[<center>(最终效果展示)</center><p><img src="/2024/03/10/Implement_Building_System_With_GAS/building_structures_with_gas.gif"></p><p>在很多提供建造玩法的项目案例中，往往是定义 ActorComponent 类并在那里实现启用建造功能、选择建造位置、轻微调整建筑物、生成建筑物等功能，随后角色类会使用该 ActorComponent 的实例，从而获得建造建筑的能力。这需要开发者处理玩家能否启用建造功能，例如当玩家获得阵亡、沉睡、眩晕等状态时需要阻止建筑功能逻辑的执行，并且停止正在进行的建造进程。</p><p>除此之外，很多解决方案还采取了引入若干个碰撞频道来实现建筑物对齐功能，这会至少引发三个问题：1. 迁移代码到其他项目时总是需要添加这些额外的碰撞频道；2. 每次引入新的碰撞频道时，需要检查之前的建筑物是否已经忽略了新频道，避免出现错误的对齐；3. 开发者需要检查每个 BoxComponent 是否正确阻挡了对应的频道，增加了因开发者分心、遗忘所造成的程序错误逻辑概率。所以这篇博客集中于以下几点实现建造功能：</p><ul><li>将建造功能作为一项 Ability 来实现，后期玩家获得的状态影响着玩家是否能够激活该技能；</li><li>设计师只需要按照命名规范为 BoxComponent 起合适的名字，并调整对齐位置点即可。</li></ul><h2 id="建筑物的识别与对齐"><a href="#建筑物的识别与对齐" class="headerlink" title="建筑物的识别与对齐"></a>建筑物的识别与对齐</h2><p>在玩家尝试进行一次建造物的生成时，通常更愿意将其摆放在已存在建筑物的附近，因此为玩家提供辅助对齐的机制尤为重要。在建筑物类内部可以看到很多 BoxComponent 出现在 StaticMeshComponent 的附近，它们用于指定可以摆放在那里的建筑类类型。在下图中，可以看到地基类建筑可以设置其他地基、墙壁可以对齐的位置。</p><p><img src="/2024/03/10/Implement_Building_System_With_GAS/demo_foundation_structure.png"></p><p>在玩家挪动预览建筑物的位置时，射线追踪的结果会尝试寻找匹配的 BoxComponent，如果建筑物类型匹配则设置预览建筑物的变换到该 BoxComponent 的。具体的逻辑实现在下一节中展开详述，本节讨论如何为 BoxComponent 附上合适的建筑物类型。</p><p>我个人比较喜欢的是让每一个行为都有意义，包括为 BoxComponent 实例命名。在上图左上角可以看到<code>FoundationX</code>、<code>WallX</code>格式的名字，这些数字（X）前面的字符串就为 BoxComponent 定义了类型。这样名字不仅帮助设计师区分不同组件，还进一步确定了它可以对齐的建筑物类型（如建筑物类型为 Wall 的实例只能对齐到 Wall 开头的 BoxComponent 中）。为实现这种名称决定类型的功能，我们需要一个枚举类和 BoxComponent 派生类，具体实现如下：</p><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EStructureType</span> : uint8{None,Foundation,Wall,<span class="hljs-comment">// other stuff</span>};<span class="hljs-keyword">class</span> <span class="hljs-title class_">UBota_BoxComponent</span> : <span class="hljs-keyword">public</span> UBoxComponent; <span class="hljs-function">EStructureType <span class="hljs-title">UBota_BoxComponent::GetCollisionType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>{<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; EnumPtr = <span class="hljs-built_in">FindObject</span>&lt;UEnum&gt;(ANY_PACKAGE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">"EStructureType"</span>), <span class="hljs-literal">true</span>);<span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; EnumPtr-&gt;<span class="hljs-built_in">NumEnums</span>(); ++i){<span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetNameSafe</span>(<span class="hljs-keyword">this</span>).<span class="hljs-built_in">StartsWith</span>(EnumPtr-&gt;<span class="hljs-built_in">GetNameStringByIndex</span>(i))){<span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;EStructureType&gt;(EnumPtr-&gt;<span class="hljs-built_in">GetValueByIndex</span>(i));}}<span class="hljs-keyword">return</span> EStructureType::None;}</code></pre><p>在上述代码中<code>EStructureType</code>决定了当前项目中有哪些建筑物类型。自定义的<code>UBota_BoxComponent</code>提供了返回建筑类型的函数，在函数体内会根据自己的名字找到匹配的建筑枚举项并返回。这种实现方式使用到了虚幻引擎提供的反射机制，设计师也可以随时在<code>EStructureType</code>添加新的建筑物类型，而无需修改<code>UBota_BoxComponent</code>的代码。</p><p>在很多解决方案中，摧毁一个建筑物可能会引发其他建筑物的一同销毁，例如一块地基建筑物被销毁时会连同周围的墙壁、墙壁附近的物品一起销毁，但不会影响其他地基建筑物的销毁，此时可以遍历 <code>UBota_BoxComponent</code> 组件从而筛选出满足条件的建筑物。</p><h2 id="实现技能前的准备工作"><a href="#实现技能前的准备工作" class="headerlink" title="实现技能前的准备工作"></a>实现技能前的准备工作</h2><p>在 GAS 插件下，需要玩家挑选和确认施法位置时会用到继承自<code>AGameplayAbilityTargetActor</code>的类实例（以下简称 TargetActor）。除了作为一个 Actor 存在，它还封装了一个<code>FGameplayAbilityTargetData</code>（以下简称 TargetData），在玩家发出确认目标的请求时就会将处理后的信息封装成<code>FGameplayAbilityTargetDataHandle</code>（以下简称 TargetDataHandle）然后以委托的形式传递出去，这是一种在 Ability 类中客户端向服务器通信发送数据的方式。</p><p>虚幻官方提供了如 GroundTace、SingleLineTrace 等派生类供开发者直接使用，这些派生类会在射线追踪中将<code>FGameplayAbilityTargetingLocationInfo</code>的实例传递出去，在一些仅需要位置信息的技能中很有用。然而对于建造技能来说，除了位置信息我们还需要知道玩家设置的旋转信息，以便于建筑物拥有玩家预期的变换。因此需要：</p><ol><li>能够传递位置和旋转信息（这里假设了缩放大小保持在 1）；</li><li>作为预览建筑物的 TargetActor 能尝试寻找<code>UBota_BoxComponent</code>实例并对齐；</li><li>能在自定义的 TargetData 和 TargetDataHandle 之间来回转换。</li></ol><p>自定义 TargetData 中最关键的要求就是变量类型实现了网络序列化（有<code>NetSerialize</code>函数可用），在本案例中，<code>FVector_NetQuantize100</code>和<code>FRotator</code>都被虚幻引擎官方实现了网络序列化，故整个工作流程就只是使用如同下面的模板来定义一个 TargetData：</p><pre><code class="hljs C++"><span class="hljs-built_in">USTRUCT</span>(BlueprintType)<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BOTA_API</span> FGameplayAbilityTargetData_LocationAndRotation : <span class="hljs-keyword">public</span> FGameplayAbilityTargetData{<span class="hljs-built_in">GENERATED_BODY</span>()<span class="hljs-built_in">FGameplayAbilityTargetData_LocationAndRotation</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)FVector_NetQuantize100 Location;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)FRotator Rotation;<span class="hljs-function"><span class="hljs-keyword">virtual</span> UScriptStruct* <span class="hljs-title">GetScriptStruct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">return</span> FGameplayAbilityTargetData_LocationAndRotation::<span class="hljs-built_in">StaticStruct</span>();}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NetSerialize</span><span class="hljs-params">(FArchive&amp; Ar, <span class="hljs-keyword">class</span> UPackageMap* Map, <span class="hljs-type">bool</span>&amp; bOutSuccess)</span></span><span class="hljs-function"></span>{Location.<span class="hljs-built_in">NetSerialize</span>(Ar, Map, bOutSuccess);Rotation.<span class="hljs-built_in">NetSerialize</span>(Ar, Map, bOutSuccess);bOutSuccess = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}};<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TStructOpsTypeTraits</span>&lt;FGameplayAbilityTargetData_LocationAndRotation&gt; : <span class="hljs-keyword">public</span> TStructOpsTypeTraitsBase2&lt;FGameplayAbilityTargetData_LocationAndRotation&gt;{<span class="hljs-keyword">enum</span>{WithNetSerializer = <span class="hljs-literal">true</span> };};</code></pre><p>接下来的任务就是定义 TargetActor，作为预览建筑物辅助玩家选择要将建筑物放置在哪里。TargetActor 有几个信息可以先了解一下（函数无签名信息）：</p><ul><li><code>StartTargeting()</code>：初始化函数，可以得到 Ability 的信息，进而获得 Avatar、AbilitySystemComponent （以下简称 ASC）等信息。从而在<code>Tick()</code>函数中找到玩家的位置和看向的方向，确定射线追踪的参数。</li><li><code>ConfirmTargetingAndContinue()</code>：玩家对 ASC 调用了 <code>TargetConfirm()</code> 函数，代表玩家此时决定在此处生成 TargetData。在本例中代表玩家已经确定了新建筑物要放置在哪里。</li><li><code>IsConfirmTargetingAllowed()</code>：通常在上一条函数中调用，有时 TargetActor 所掌握的信息不能生成 TargetData，返回一个布尔值来信息是否满足条件。在本例中，墙壁类建筑物不允许随意放置，只允许放置在 UBota_BoxComponent 的类型是 Wall 之中，具体来说必须在地基或者其他墙壁之上，所以出现在其他地方时阻止玩家生成建筑物实例。</li><li><code>StartLocation</code>：一个 FGameplayAbilityTargetingLocationInfo 类型的实例，包含一个位置信息可以广播。</li></ul><p>本例定义了一个派生自<code>AGameplayAbilityTargetActor_SingleLineTrace</code>的新类，覆盖了其<code>Tick()</code>、<code>ConfirmTargetingAndContinue()</code>和<code>IsConfirmTargetingAllowed()</code>函数。</p><p>在 Tick 函数会展开射线追踪检测，得到 FHitResult 实例后判断 Component 是否为 Bota_BoxComponent，如果是就设置 TargetActor 为 Component 的变换，否则就使用射线检测的 TraceEnd 作为 TargetActor 的位置。由于基类假设的是玩家并不会移动，但我们希望玩家可以边移动边选择放置处，这意味着需要更新<code>StartLocation</code>的信息：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PreviewTargetActor::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaSeconds)</span></span><span class="hljs-function"></span>{StartLocation.LiteralTransform.<span class="hljs-built_in">SetLocation</span>(SourceActor-&gt;<span class="hljs-built_in">GetActorLocation</span>());<span class="hljs-keyword">auto</span> HitResult = <span class="hljs-built_in">PerformTrace</span>(SourceActor);BuildTransform.<span class="hljs-built_in">SetLocation</span>(HitResult.Component.<span class="hljs-built_in">IsValid</span>() ? HitResult.ImpactPoint : HitResult.TraceEnd);bCanBuild = bFreePlacement;<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Component = <span class="hljs-built_in">Cast</span>&lt;UBota_BoxComponent&gt;(HitResult.Component)){<span class="hljs-keyword">if</span> (Component-&gt;<span class="hljs-built_in">GetCollisionType</span>() == StructureType){BuildTransform.<span class="hljs-built_in">SetLocation</span>(Component-&gt;<span class="hljs-built_in">GetComponentLocation</span>());BuildTransform.<span class="hljs-built_in">SetRotation</span>(Component-&gt;<span class="hljs-built_in">GetComponentRotation</span>().<span class="hljs-built_in">Quaternion</span>());bCanBuild = <span class="hljs-literal">true</span>;}}<span class="hljs-built_in">SetActorTransform</span>(BuildTransform);}</code></pre><p>通常在建造游戏中玩家可以使用<code>Q</code> <code>E</code>或者鼠标滚轮实现预览建筑物在 Yaw 轴上进行旋转，为了实现这个功能，可以引入两个<code>GameplayTag</code>并在对应按键按下和释放时分别对<code>ASC</code>调用<code>AddLooseGameplayTag()</code>和<code>RemoveLooseGameplayTag()</code>，使得 TargetActor 和玩家之间通过标签来通信，具体实现是：</p><pre><code class="hljs C++"><span class="hljs-comment">// Bota_GameplayTags.cpp</span><span class="hljs-built_in">UE_DEFINE_GAMEPLAY_TAG</span>(Tag_Input_Rotate_Up, <span class="hljs-string">"Input.Rotate.Up"</span>);<span class="hljs-built_in">UE_DEFINE_GAMEPLAY_TAG</span>(Tag_Input_Rotate_Down, <span class="hljs-string">"Input.Rotate.Down"</span>);<span class="hljs-comment">// Bota_PlayerCharacter.cpp 仅展示了 Rotate_Down 标签</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PlayerCharacter::OnRotateBuildingPressed</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">AddLooseGameplayTag</span>(Tag_Input_Rotate_Down);}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PlayerCharacter::OnRotateBuildingReleased</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">RemoveLooseGameplayTag</span>(Tag_Input_Rotate_Down);}}<span class="hljs-comment">// Bota_PreviewTargetActor.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PreviewTargetActor::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaSeconds)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">// ... 与之前相同</span><span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = UAbilitySystemBlueprintLibrary::<span class="hljs-built_in">GetAbilitySystemComponent</span>(SourceActor)){<span class="hljs-keyword">auto</span> NewRotation = BuildTransform.<span class="hljs-built_in">Rotator</span>();<span class="hljs-keyword">if</span> (ASC-&gt;<span class="hljs-built_in">GetGameplayTagCount</span>(Tag_Input_Rotate_Down)){NewRotation = UKismetMathLibrary::<span class="hljs-built_in">ComposeRotators</span>(NewRotation, <span class="hljs-built_in">FRotator</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>));}<span class="hljs-keyword">if</span> (ASC-&gt;<span class="hljs-built_in">GetGameplayTagCount</span>(Tag_Input_Rotate_Up)){NewRotation = UKismetMathLibrary::<span class="hljs-built_in">ComposeRotators</span>(NewRotation, <span class="hljs-built_in">FRotator</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">0</span>));}BuildTransform.<span class="hljs-built_in">SetRotation</span>(NewRotation.<span class="hljs-built_in">Quaternion</span>());}<span class="hljs-comment">// ... 与之前相同</span>}</code></pre><p>接下来需要考虑实现如何将自定义的 TargetData 封装为 TargetDataHandle，并在<code>ConfirmTargetingAndContinue()</code> 中广播出去。下面的代码是比较模板化的代码，结构体实例也通常使用 C++ 的<code>new</code>关键字来创建实例并对实例的数据成员赋值，最后新定义一个 TargetDataHandle 并将刚才的实例添加进去并返回。</p><pre><code class="hljs C++"><span class="hljs-function">FGameplayAbilityTargetDataHandle  <span class="hljs-title">ABota_PreviewTargetActor::MakeTargetData_LocationAndRotation</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">auto</span> Data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FGameplayAbilityTargetData_LocationAndRotation</span>();Data-&gt;Location = <span class="hljs-built_in">GetActorLocation</span>();Data-&gt;Rotation = <span class="hljs-built_in">GetActorRotation</span>();<span class="hljs-keyword">auto</span> Handle = <span class="hljs-built_in">FGameplayAbilityTargetDataHandle</span>();Handle.<span class="hljs-built_in">Add</span>(Data);<span class="hljs-keyword">return</span> Handle;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PreviewTargetActor::ConfirmTargetingAndContinue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">check</span>(<span class="hljs-built_in">ShouldProduceTargetData</span>());<span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsConfirmTargetingAllowed</span>()){bDebug = <span class="hljs-literal">false</span>;FGameplayAbilityTargetDataHandle Handle = <span class="hljs-built_in">MakeTargetData_LocationAndRotation</span>();TargetDataReadyDelegate.<span class="hljs-built_in">Broadcast</span>(Handle);}}</code></pre><p>在蓝图中，自定义的 TargetData 并没有直接的方法来获得里面存储的位置和旋转信息，因此需要实现一个单独的函数来将 TargetDataHandle 里面存储的自定义 TargetData 读取出来。这个函数可以是静态的，可以定义在 <code>UGameplayAbility</code> 或者 <code>UBlueprintFunctionLibrary</code> 中，本例中实现在了 GA 下：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_GameplayAbility::GetTransformFromTargetData</span><span class="hljs-params">(FGameplayAbilityTargetDataHandle Handle, <span class="hljs-type">const</span> <span class="hljs-type">int</span> Index, FTransform&amp; Transform)</span></span><span class="hljs-function"></span>{    FGameplayAbilityTargetData* Data = Handle.<span class="hljs-built_in">Get</span>(Index);    <span class="hljs-keyword">if</span> (!Data)    {        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">if</span> (Data-&gt;<span class="hljs-built_in">GetScriptStruct</span>() == FGameplayAbilityTargetData_LocationAndRotation::<span class="hljs-built_in">StaticStruct</span>())    {        <span class="hljs-keyword">auto</span> MyData = <span class="hljs-built_in">static_cast</span>&lt;FGameplayAbilityTargetData_LocationAndRotation*&gt;(Data);        Transform.<span class="hljs-built_in">SetLocation</span>(MyData-&gt;Location);        Transform.<span class="hljs-built_in">SetRotation</span>(MyData-&gt;Rotation.<span class="hljs-built_in">Quaternion</span>());        Transform.<span class="hljs-built_in">SetScale3D</span>(<span class="hljs-built_in">FVector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));    }}</code></pre><h2 id="实现技能逻辑"><a href="#实现技能逻辑" class="headerlink" title="实现技能逻辑"></a>实现技能逻辑</h2><p>在本例中将技能逻辑的实现放在了蓝图，这是因为预览建筑物类中设置了一些<code>Expose On Spawn</code> 的变量，我暂时在 C++ 中没有找到在技能任务执行之前，对这些变量初始化的办法。在蓝图中，我将技能的触发器设置为由 <code>GameplayEvent</code> 触发并且约定<code>Optional Object</code>中存储着建筑类的信息。随后调用<code>WaitTargetData</code>任务并选择之前定义的预览建筑物 TargetActor 并设置好建筑物信息，在<code>Valid Data</code>执行中让服务器生成具体的 Actor 实例，进一步设置<code>Owner</code>为玩家，这样就可以在建筑物类中定义<code>RPC</code>并不会报没有网络链路的错误了，在本例中开关门的动作就是调用 Server 函数，随后 NetMulticast 执行开关门的动画。蓝图节点的总览如下：</p><p><img src="/2024/03/10/Implement_Building_System_With_GAS/ga_build_screenshot.png" alt="GA_Build"></p><h2 id="触发技能的执行"><a href="#触发技能的执行" class="headerlink" title="触发技能的执行"></a>触发技能的执行</h2><p>在本例中，我使用一个 <code>class UBota_StructureDataAsset : public UPrimaryDataAsset</code> 来存储着建筑物的信息，有些如建筑物的名字、缩略图等信息定义在此处，而具体的网格资产和逻辑都是在 Actor 类中选择。在预览建筑物 TargetActor 中找到建筑物类的类默认对象，从而读取网格资产信息。这样就不用在<code>DataAsset</code>和建筑物类中设置两次网格资产等其他信息，减少重复性行为。</p><pre><code class="hljs C++"><span class="hljs-comment">// Bota_PreviewTargetActor.cpp</span><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; DefaultStructureActor = <span class="hljs-built_in">GetDefault</span>&lt;ABota_StructureActor&gt;(StructureDataAsset-&gt;ActorToSpawn);StructureType = DefaultStructureActor-&gt;StructureType;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Mesh = DefaultStructureActor-&gt;StaticMeshComponent-&gt;<span class="hljs-built_in">GetStaticMesh</span>();StaticMeshComponent-&gt;<span class="hljs-built_in">SetStaticMesh</span>(Mesh);bFreePlacement = DefaultStructureActor-&gt;bFreePlacement;</code></pre><p>在<code>AssetManager</code>中添加<code>UBota_StructureDataAsset</code>后就可以使用 <code>Get Primary Asset Id List</code> 和 <code>Async Load Primary Asset List</code> 节点来加载所有建筑物了。选择需要建造的建筑物后，就可以调用 <code>Send Gameplay Event To Actor</code>来触发技能的执行了。</p><p><img src="/2024/03/10/Implement_Building_System_With_GAS/try_active_build_ability_by_tag.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;(最终效果展示)&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/2024/03/10/Implement_Building_System_With_GAS/building_structures_with_gas.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;在很多提供建造玩法的项</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="GAS" scheme="http://www.yerha.top/tags/GAS/"/>
    
    <category term="BuildingSystem" scheme="http://www.yerha.top/tags/BuildingSystem/"/>
    
  </entry>
  
</feed>
