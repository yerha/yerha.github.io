<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.yerha.top/atom.xml" rel="self"/>
  
  <link href="http://www.yerha.top/"/>
  <updated>2024-04-07T03:48:04.302Z</updated>
  <id>http://www.yerha.top/</id>
  
  <author>
    <name>Yerha</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何用 InputAction 来触发 GameplayAbility 的激活</title>
    <link href="http://www.yerha.top/2024/04/07/binding-IA-to-GA/"/>
    <id>http://www.yerha.top/2024/04/07/binding-IA-to-GA/</id>
    <published>2024-04-07T01:49:27.000Z</published>
    <updated>2024-04-07T03:48:04.302Z</updated>
    
    <content type="html"><![CDATA[<p>GAS 作为管理技能和属性相关的灵活插件，使得开发制作角色扮演游戏、多人在线战术竞技游戏不再那么繁琐。另一方面，虚幻引擎将增强输入系统作为了默认输入组件，这不仅使得按下、按下并按住等常见功能逻辑作为了内置功能，还引入了上下文和优先级机制，使得我们可以将同一个按键在不同的上下文中发挥不同的效果。</p><p>如果有机会通过增强输入系统中的输入动作映射到 GAS 的技能激活，那么就可以以很优雅的方式在不同上下文中激活不同的技能。例如鼠标左键在未装备武器时激活挥拳技能、装备枪械时变为开火技能；空格键可以先作为跳跃技能的触发按钮，后期又可以灵活地替换成翻滚技能的触发按钮。本博文将讨论以下几点内容：</p><ul><li>何时应该赋予角色技能，以及输入事件的绑定；</li><li>如何保证所有技能任务都正确工作，尤其是等待输入 ID 按下和释放的技能任务；</li><li>有些技能不需要按键来触发，怎么维护需要按键和不需要按键的技能。</li></ul><h2 id="赋予角色技能的时机"><a href="#赋予角色技能的时机" class="headerlink" title="赋予角色技能的时机"></a>赋予角色技能的时机</h2><p>根据个人过去游戏开发的经历，赋予角色技能的时机通常分为两种情况：1. 所有的技能在初始化技能系统组件后，一次性全部获得；2. 部分技能在初始化技能系统组件后获得，剩余技能在游戏期间中逐渐获得。通俗点儿说，前者更像是玩家已经化身为 “大师”，只是需要根据游戏的进程来明白自己并非 “凡夫俗子”；后者通常像是一件物品对玩家说：“想弄懂我就装备我吧”，例如只有装备枪械时才会得到开火和换子弹的技能，卸下装备时就失去了这两个技能。</p><p>从开发的角度来说，一次性赋予的方式最为直接，但有着十分苛刻的技能激活的判断条件，要确保玩家激活了预期的技能。而部分赋予的方式间接引入了上下文的概念，只有满足特定条件和身处特定环境时才能得到激活技能的机会，在 GAS 框架下还有机会为技能提供 <code>SourceObject</code> 信息，从而在技能内部获取物品的信息，比如说开火技能可以找到武器网格中枪口 <code>Socket</code>、开火间隔的信息。但部分赋予的方式还可能会引发频繁地技能赋予和取消，比如游戏为玩家提供了 <code>Q</code> 键或鼠标滚轮来切换武器的机制，而包括在我内的一些玩家非常喜欢频繁切换它们，结果上是玩家频繁地获取和失去相同的技能。最后是部分赋予的方式还会使得 <code>InputID</code> 难以维护，该值在赋予技能的时候显式地提供，且通常是被前言中提到的技能任务有关，而我们更愿意使设计师可以用到的节点都能正常工作。</p><p>从上面的描述中看来，一次性赋予的方式会使得生活更加容易一些，我们需要做好就是确保判断技能激活的条件，而虚幻引擎增强输入系统的上下文机制可以辅助我们解决这个问题。当玩家获得装备时（通常在 <code>BeginPlay</code>），将玩家的输入上下文中增加开火上下文，在卸下时去掉开火上下文（通常在 <code>EndPlay</code>）。在我的实现版本中，我将技能定义为了结构体，角色类中有存储该结构体的数组，然后在初始化技能系统函数中赋予玩家这些能力：</p><pre><code class="hljs CPP"><span class="hljs-built_in">USTRUCT</span>(BlueprintType)<span class="hljs-keyword">struct</span> <span class="hljs-title class_">FBota_AbilityInputActionBinding</span>{<span class="hljs-built_in">GENERATED_BODY</span>()<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)TSubclassOf&lt;UGameplayAbility&gt; AbilityClass;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)TObjectPtr&lt;UInputAction&gt; InputAction;};<span class="hljs-comment">// ABota_Character 中有 TArray&lt;FBota_AbilityInputActionBinding&gt; AbilityBindings</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::OnInitAbilityActorInfo</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetBotaAbilitySystemComponent</span>();<span class="hljs-keyword">if</span> (!ASC)<span class="hljs-keyword">return</span>;AActor* InOwner = <span class="hljs-literal">nullptr</span>, *InAvatar = <span class="hljs-literal">nullptr</span>;<span class="hljs-built_in">GetAbilitySystemAvatarAndOwner</span>(InOwner, InAvatar);ASC-&gt;<span class="hljs-built_in">InitAbilityActorInfo</span>(InOwner, InAvatar);<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">HasAuthority</span>())<span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Binding : AbilityBindings){<span class="hljs-keyword">if</span>(Binding.AbilityClass)ASC-&gt;<span class="hljs-built_in">GiveAbilityAndAssignInputID</span>(<span class="hljs-built_in">FGameplayAbilitySpec</span>(Binding.AbilityClass));}}</code></pre><p>在代码中可以看到，在服务器端使用了自定义的函数 <code>GiveAbilityAndAssignInputID</code>，它在 <code>GiveAbility</code> 的基础上还会为技能提供一个有效的 <code>InputID</code>。它的实现如下：</p><pre><code class="hljs CPP"><span class="hljs-comment">// UBota_AbilitySystemComponent 中有 int32 ValidInputID = 0</span><span class="hljs-function">FGameplayAbilitySpecHandle <span class="hljs-title">UBota_AbilitySystemComponent::GiveAbilityAndAssignInputID</span><span class="hljs-params">(<span class="hljs-type">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">auto</span> TempAbilitySpec = AbilitySpec;TempAbilitySpec.InputID = ValidInputID;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; SpecHandle = <span class="hljs-built_in">GiveAbility</span>(TempAbilitySpec);<span class="hljs-keyword">if</span> (SpecHandle.<span class="hljs-built_in">IsValid</span>()){ValidInputID++;}<span class="hljs-keyword">return</span> SpecHandle;}</code></pre><h2 id="输入的绑定"><a href="#输入的绑定" class="headerlink" title="输入的绑定"></a>输入的绑定</h2><p>在上一节定义的结构体中，可以看到 <code>TObjectPtr&lt;UInputAction&gt; InputAction</code> 成员，这是设计师可以为技能映射按键的位置。这个 <code>InputAction</code> 可以加入到角色默认的 <code>InputMappingContext</code> 中，这样玩家一开始就可以通过按下对应的按键来激活技能，也可以加入到其他的 <code>InputMappingContext</code> 中然后动态地添加角色的输入系统中。在这种的实现机制中，<code>AbilityBindings</code> 在运行时保持值不变，因此可以很安全地遍历数组。下面的代码演示了如何将 <code>InputAction</code> 进行绑定并且在回调函数中找到对应的技能并激活：</p><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::SetupPlayerInputComponent</span><span class="hljs-params">(UInputComponent* PlayerInputComponent)</span></span><span class="hljs-function"></span>{Super::<span class="hljs-built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; EIC = <span class="hljs-built_in">CastChecked</span>&lt;UEnhancedInputComponent&gt;(PlayerInputComponent);<span class="hljs-keyword">if</span> (!EIC)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Binding : AbilityBindings){<span class="hljs-keyword">if</span> (!Binding.InputAction)<span class="hljs-keyword">continue</span>;EIC-&gt;<span class="hljs-built_in">BindAction</span>(Binding.InputAction, ETriggerEvent::Started, <span class="hljs-keyword">this</span>, &amp;ThisClass::InputActionPressed, Binding.AbilityClass);EIC-&gt;<span class="hljs-built_in">BindAction</span>(Binding.InputAction, ETriggerEvent::Completed, <span class="hljs-keyword">this</span>, &amp;ThisClass::InputActionReleased, Binding.AbilityClass);}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::InputActionPressed</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityClass)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (!InAbilityClass)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetBotaAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">FindAbilityByClassAndPressedInputID</span>(InAbilityClass);}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_Character::InputActionReleased</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityClass)</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (!InAbilityClass)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetBotaAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">FindAbilityByClassAndRelesedInputID</span>(InAbilityClass);}}</code></pre><p>虚幻引擎的委托绑定函数允许我们额外传递函数形参，所以在上面的代码中在回调函数中将 <code>InputAction</code> 映射的 <code>AbilityClass</code> 传递了过来，然后调用了 <code>AbilitySystemComponent</code> 中自定义的函数 <code>FindAbilityByClassAndPressedInputID</code> 和 <code>FindAbilityByClassAndRelesedInputID</code> 来实现技能的触发。</p><h2 id="寻找技能实例然后激活它"><a href="#寻找技能实例然后激活它" class="headerlink" title="寻找技能实例然后激活它"></a>寻找技能实例然后激活它</h2><p>在 <code>InputAction</code> 的回调函数中调用了 <code>AbilitySystemComponent</code> 的函数 <code>FindAbilityByClassAndPressedInputID</code> 和 <code>FindAbilityByClassAndRelesedInputID</code>，我采取的实现是结合了 <code>TryActivateAbilityByClass</code> 、<code>AbilityLocalInputPressed</code> 和 <code>AbilityLocalInputReleased</code>。因为这些函数会在调用时各自遍历一次可激活技能数组，所以修改为了只遍历一次：</p><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_AbilitySystemComponent::FindAbilityByClassAndPressedInputID</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate)</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">ABILITYLIST_SCOPE_LOCK</span>();<span class="hljs-type">const</span> UGameplayAbility* <span class="hljs-type">const</span> InAbilityCDO = InAbilityToActivate.<span class="hljs-built_in">GetDefaultObject</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Spec : ActivatableAbilities.Items){<span class="hljs-keyword">if</span> (Spec.Ability == InAbilityCDO){<span class="hljs-keyword">if</span> (Spec.Ability){Spec.InputPressed = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (Spec.<span class="hljs-built_in">IsActive</span>()){<span class="hljs-keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; <span class="hljs-built_in">IsOwnerActorAuthoritative</span>() == <span class="hljs-literal">false</span>){<span class="hljs-built_in">ServerSetInputPressed</span>(Spec.Handle);}<span class="hljs-built_in">AbilitySpecInputPressed</span>(Spec);<span class="hljs-built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, Spec.ActivationInfo.<span class="hljs-built_in">GetActivationPredictionKey</span>());}<span class="hljs-keyword">else</span>{<span class="hljs-built_in">TryActivateAbility</span>(Spec.Handle);}}}}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_AbilitySystemComponent::FindAbilityByClassAndRelesedInputID</span><span class="hljs-params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate)</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">ABILITYLIST_SCOPE_LOCK</span>();<span class="hljs-type">const</span> UGameplayAbility* <span class="hljs-type">const</span> InAbilityCDO = InAbilityToActivate.<span class="hljs-built_in">GetDefaultObject</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; Spec : ActivatableAbilities.Items){<span class="hljs-keyword">if</span> (Spec.Ability == InAbilityCDO){Spec.InputPressed = <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (Spec.Ability &amp;&amp; Spec.<span class="hljs-built_in">IsActive</span>()){<span class="hljs-keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; <span class="hljs-built_in">IsOwnerActorAuthoritative</span>() == <span class="hljs-literal">false</span>){<span class="hljs-built_in">ServerSetInputReleased</span>(Spec.Handle);}<span class="hljs-built_in">AbilitySpecInputReleased</span>(Spec);<span class="hljs-built_in">InvokeReplicatedEvent</span>(EAbilityGenericReplicatedEvent::InputReleased, Spec.Handle, Spec.ActivationInfo.<span class="hljs-built_in">GetActivationPredictionKey</span>());}}}}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GAS 作为管理技能和属性相关的灵活插件，使得开发制作角色扮演游戏、多人在线战术竞技游戏不再那么繁琐。另一方面，虚幻引擎将增强输入系统作为了默认输入组件，这不仅使得按下、按下并按住等常见功能逻辑作为了内置功能，还引入了上下文和优先级机制，使得我们可以将同一个按键在不同的上下</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="GAS" scheme="http://www.yerha.top/tags/GAS/"/>
    
    <category term="EnhancedInputSystem" scheme="http://www.yerha.top/tags/EnhancedInputSystem/"/>
    
  </entry>
  
  <entry>
    <title>进阶运动动画的实现</title>
    <link href="http://www.yerha.top/2024/03/24/Advanced-Locomotion-Animation-Logic/"/>
    <id>http://www.yerha.top/2024/03/24/Advanced-Locomotion-Animation-Logic/</id>
    <published>2024-03-24T02:07:38.000Z</published>
    <updated>2024-03-25T03:54:45.915Z</updated>
    
    <content type="html"><![CDATA[<p>自虚幻引擎5发布以来，Epic 官方提供了很多实用的工具来处理动画资产，在初学者项目 Lyra 中不仅可以看到这些工具的具体应用，还提供了一个进阶版本的动画逻辑解决方案（相较于第三人称射击模板附带的动画蓝图）。本博文主要讨论这套方案的以下几个要点：</p><ul><li>如何修改动画序列数据以满足该解决方案的资产要求；</li><li>如何减轻游戏主线程的负担，让动画逻辑不成为性能瓶颈；</li><li>如何在运行时灵活地替换部分动画，例如玩家装备武器时，将无持械的动画替换为该武器对应的动画。</li></ul><p>为了使这套解决方案可以正确工作，以及方便动画资产的处理，需要项目启用<code>Animation Locomotion Library</code>、<code>Animation Warping</code>、<code>Animation Modifier Library</code>插件。本解决方案对应的角色旋转设置如下：</p><pre><code class="hljs CPP"><span class="hljs-comment">// 角色的朝向跟随 ControllRotation</span>bUseControllerRotationYaw = <span class="hljs-literal">true</span>;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; CharMovement = <span class="hljs-built_in">GetCharacterMovement</span>();CharMovement-&gt;bOrientRotationToMovement = <span class="hljs-literal">false</span>;</code></pre><h2 id="动画序列资产"><a href="#动画序列资产" class="headerlink" title="动画序列资产"></a>动画序列资产</h2><p>在 Lyra 中，角色的地面运动主要分为站立步行（Walk）、站立奔跑（Jog）和蹲下行走（Crouch）三种姿态，每种姿态都有空闲（Idle）和前后左右的开始（Start）、运动（Cycle）、结束（Stop）、枢轴（Pivot）动画。在开始、结束和枢轴动画中要求资产有名为 Distance 的曲线，标志着在当前帧在动画里移动的距离。这会在运行时通过计算真实运动的距离来调整序列的播放进度，比如角色停下需要往前走 100 厘米才能将速度大小降为零，在动画蓝图中需要找到 100 厘米对应的帧是多少然后从那里开始播放，还会在每帧根据移动距离随时调整播放进度。枢轴主要处理在运动状态下加速度与速度方向角度大于九十度时的情况，例如在往前走的状态中，玩家输入了往后走时，需要表现出先成往前跑的姿势停下来，然后再开始往后跑的姿势。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/showcase_distance_curve.png"></p><p>在制作这样的曲线前，需要先定义一个<code>Curve Compression Settings</code>，并设置编码方式为 Uniform Indexable，这是虚幻引擎在文档中的要求，以确保可以在运行时访问到曲线信息。具体是在内容浏览器中按下鼠标右键，依次选择 Animation / Advanced / Curve Compression Settings，双击打开新资产为 Codec 设置 Uniform Indexable。所有需要使用曲线信息的动画序列里，Asset Details / Compression / Curve Compression Settings 赋为新建的压缩设置。对于多个动画序列资产，可以选中它们然后右键 Asset Actions / Edit Selection in Property Matrix，以实现批量修改。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/curve_compression_settings_in_property_matrix.png"></p><p>制作这样的曲线，并不需要我们手动绘制。在动画序列编辑器中 Window 菜单下有一个 Animation Data Modifier 选项，点击它就会出现一个窗口，在这个窗口下可以借助一系列的修改器生成符合满足需求的曲线、轨道（Track）和通知（Notify）。其中就有一个<code>DistanceCurveModifier</code>，它就可以自动生成我们需要的曲线。在 Asset Details 中勾选<code>Enable Root Motion</code>选项后就可以右键应用修改器了。同样如果多个序列都需要这样的设置时，可以先用上文提到的 Property Matrix 来勾选<code>Enable Root Motion</code>后，对这些右键选择 Animation Modifier(s) / Add New Modifiers 来添加和应用修改器。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/distance_curve_modifier_UI.png"></p><p>除了创建 Distance 曲线，推荐进一步应用<code>SyncMarkerAnimModifier</code>，它会创建一个<code>FootSyncMarkers</code>轨道并在里面创建若干个标记为 L 和 R 的通知，后期在动画蓝图中选择同步组后，就可以实现不同动画之间过渡时能匹配姿势，产生连贯地动画。</p><p>除了地面运动外，还有一些跳跃有关的动画，分别是跳跃开始（JumpStart）、跳跃开始循环（JumpStartLoop）、跳跃到极点（JumpApex）、下落循环（FallLoop）以及下落着陆（FallLand）。可以为这些资产加上 <code>DistableFootIK</code>的曲线，确保腿部不会尝试寻找可以落脚的位置。而对于下落着陆动画中还需要添加一个<code>GroundDistance</code>的曲线，表示每一帧到地面的距离，在实际下落时可以计算到地面的距离值来调整播放进度。这同样是通过<code>DistanceCurveModifier</code>实现的，在配置中设置轴（Axis）为<code>Z</code>即可。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/ground_distance_in_fall_land_sequence.png"></p><h2 id="动画蓝图与动画层"><a href="#动画蓝图与动画层" class="headerlink" title="动画蓝图与动画层"></a>动画蓝图与动画层</h2><p>与本博文讨论话题有关的动画相关类有三个，它们分别是：</p><ul><li><code>ABP_Mannequin_Base</code>：派生自 AnimInstance，作为角色骨骼网格组件的动画蓝图类。获取和计算 AnimGraph 使用的变量。而 AnimGraph 作为一个总的动画框架，包含运动（Locomotion）状态机、相加姿势（Additive Pose）融合、根旋转（Root Rotate）以及一些蒙太奇槽位的连接。<strong>但这里并没有具体的动画姿势</strong>，所有需要动画姿势的位置都连接了动画层接口（AnimLayersInterface）中的一个动画层。</li><li><code>ALI_ItemAnimLayers</code>：作为一个动画层接口，里面定义了一系列姿势输入与输出的动画层。可以这么思考，动画层相当于接口类中的虚函数，但必须要返回一个姿势，是否有输入姿势或其他变量则作为可选项。继承了这个接口的动画蓝图类可以使用动画层（类似调用）作为节点的输入。也可以实现接口，在运行时动态的链接（Link）到使用动画层的动画蓝图。在本例中<code>ABP_ItemAnimLayersBase</code>实现了所有的动画层，输出姿势给<code>ABP_Mannequin_Base</code>使用，后者使用动画层作为自己 AnimGraph 中一些节点的输入。</li><li><code>ABP_ItemAnimLayersBase</code>：派生自 AnimInstance。作为 ALI_ItemAnimLayers 的一个实现类，对于接口中的每个动画层都提供了有效的输出。它作为一种基类存在，将具体的姿势暴露为一个个变量，而派生类只需要为这些变量赋值即可。例如，<code>ABP_PistolAnimLayers</code>派生类只是给变量赋值，提供了角色装备手枪时的站立、运动、跳跃等动画。</li></ul><p>Lyra 并不是一个专注于射击的游戏，它支持使用<code>GameFeature</code>来增加更多的游戏玩法，官方示例中除了死斗、占点模式外，还有一个玩法完全不一样的炸弹人（类似QQ堂）模式，也允许开发者增加更多的玩法。因此，<code>ABP_Mannequin_Base</code>动画蓝图中获取与计算的变量较为基础，一些与射击模式有关的变量获取与计算工作留给了<code>ABP_ItemAnimLayersBase</code>来完成，后者与射击模式有关。如果游戏项目专门是射击玩法的话，可以考虑将<code>ABP_ItemAnimLayersBase</code>中计算变量的逻辑迁移到<code>ABP_Mannequin_Base</code>，使前者可以专注于生成姿势的逻辑。</p><hr><p>打开动画蓝图时，会发现 EventGraph 没有任何逻辑在执行。原先会在<code>BlueprintUpdateAnimation</code>中进行的逻辑，现在在<code>BlueprintThreadSafeUpdateAnimation</code>完成了，后者在逻辑中会利用多线程来分摊数据的计算，减轻了游戏主线程的负担。在这个函数中需要注意以下三点：</p><ul><li>获取外部函数和变量的值使用<code>PropertyAccess</code>节点来访问。据虚幻引擎官方介绍，该节点会在 Update 函数执行之前会对相关的变量进行缓存，读取缓存时的数据，这样一定程度上避免了数据竞争的问题，总之被官方定义为是线程安全的访问形式。</li><li>在该函数中执行的函数要勾选 Advanced / Thread Safe，线程安全的函数访问外部数据时只能使用<code>PropertyAccess</code>进行。</li><li>如果想定义可以在<code>PropertyAccess</code>节点中选择的函数，它必须是线程安全的、没有形参，返回值的名称必须是<code>ReturnValue</code>。对返回值的名称要求暂不清楚这是刻意的行为还是软件错误，如果不是这个名称则无法调用。在本例中<code>ABP_Mannequin_Base</code>定义了返回<code>UCharacterMovementComponent</code>实例的函数，而<code>ABP_ItemAnimLayersBase</code>也需要使用这个实例，但它只能使用<code>PropertyAccess</code>的形式来调用<code>ABP_Mannequin_Base</code>定义的函数。</li></ul><p>本节接下来的内容是谈论对一些变量的理解，如果不需要可以跳到下一节。</p><hr><p>在 Lyra 的实现中并不会有空闲、步行到奔跑的渐变过渡，或者说并没有一个混合空间（BlendSpace）来处理速度从 0 到 Max Walk Speed 的过渡，而是根据用户的输入直接在一帧内直接切换到另一种速度的姿态。这是基于游戏玩法设计的需求，角色的运动组件中加速度大小的增量被设置为了 2048 cm，这意味着步行的动画还没有播放几帧就已经完全在播放奔跑的了。而步行的姿态只会在一个名为<code>GameplayTag_is_ADS</code>布尔变量为 true 时播放，玩家进行精准瞄准（例如按下鼠标右键）或者静步走时会获得对应类似的标签，角色类会检查是否获得了这个标签从而改变 <code>GameplayTag_is_ADS</code>的值。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/cycle_sequence_player_select_anim_sequence.png"></p><hr><p>这里也没有四个方向运动的渐变过渡，而是计算局部速度方向角度值来设置一个 <code>AnimEnum_CardinalDirection</code>类型的枚举变量 <code>LocalVelocityDirectionNoOffset</code>，里面枚举值分别是前（Forward）、后（Backward）、左（Left）和右（Right）。在设置该枚举变量的函数<code>SelectCardinalDirectionFromAngle</code>可以发现，如果玩家持续向前或向后运动的时候，将会更难切换到向左或向右的动画，这减少了频繁切换动画的情况发生。而在混合空间中很难（好像不可能）在运行时调整各个采样的坐标。而为了让姿势更加自然，输出的姿势引脚接入了 <code>Orientation Warping</code> 节点，它会根据局部速度方向角度值来旋转角色的朝向。在浏览<code>SelectCardinalDirectionFromAngle</code>函数时，需要注意的是：1. 形参 Angle 是[-180,180]的值，正面角度是 0，反面是 -180 或 180，右面是 90，左面是 -90；2. 在判断正反面使用的是 Angle 的<strong>绝对值</strong>，但判断左右面的时候用的是 Angle <strong>原值</strong>，在复现时这里有可能会误用绝对值版本。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/select_cardinal_direction_focus_on_enlarge_dead_zone.png"><br><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/cycle_output_connects_orientation_warping.png"></p><hr><p>在<code>UpdateCharacterStateData</code>函数中可以看到，角色在竖直方向（z）的速度方向是正还是反来区分是跳跃还是下落的状态。紧接着在<code>UpdateJumpFallData</code>函数中可以看到在跳跃状态时，会以竖直方向速度大小的相反数除以重力Z值（重力值是负值，表示竖直向下的方向），作为从跳跃开始循环到跳跃极点两个动画状态之间的转换条件。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/update_jump_fall_data.png"><br><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/jump_start_loop_to_jump_apex.png"></p><hr><p>在<code>UpdateRootYawOffset</code>函数中可以看到<code>RootYawOffsetMode</code>变量的更新方法，这个变量是<code>AnimEnum_RootYawOffsetMode</code>枚举类型，一共有<code>Accmulate</code>、<code>Hold</code>和<code>BlendOut</code>三个枚举值。在外部修改这个变量时也只会是<code>Accumulate</code>和<code>Hold</code>之间的一个，前者会累加角色旋转体（Rotator）的 Yaw 值到<code>RootYawOffset</code>值上，后者保持<code>RootYawOffset</code>当前值。无论是哪一种选项，最后都会修改成<code>BlendOut</code>值，意味着下一帧如果没有修改该枚举变量的话，它会从当前的值线性插值到 0。在实际运用中，会在休闲状态（Idle）中锁在<code>Accumulate</code>值，这样旋转摄影机可以看到角色的各个面，因为根骨骼正在与摄影机在 Yaw 轴上进行相反的旋转。在开始状态（Start）时锁到<code>Hold</code>值，以当时的旋转值播放开始姿势。在运动状态（Cycle）中没有锁住该枚举变量的值，因此根骨骼会慢慢插值回到摄影机看向的方向。在停止状态（Stop）开始锁为<code>Accumulate</code>值，这样停止动画期间就可以旋转视角而不会影响角色旋转了。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-update_root_yaw_offset.png"></p><hr><p><code>LinkedLayerChanged</code>和<code>LastLinkedLayer</code>两个变量与运行时是否链接了新动画层有关，它们的更新时机是在 LocomotionSM 状态机的<code>OnUpdate</code>绑定函数中（单击状态机后在细节面板中可以找到），在内部会发现一个<code>StartLayerNode</code>的动画节点引用，在那里会检查是否与之前存储的动画层引用相同，进而触发修改逻辑。关键在于这个引用节点的创建方式，实际上它指向的是 LocomotionSM / Start 中的 FullBody_StartState，在它的细节面板中可以看到<code>Tag</code>条目，为它指定一个名字就可以在动画蓝图中引用它了。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-on_locomotionSM_update.png"></p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-fullbody_startstate_tag.png"></p><hr><p>最后需要了解的是，动画蓝图中大量使用了<code>Sequence Player</code>和<code>Sequence Evaluator</code>节点，可简单地理解为前者可以播放一个动画序列，后者在前者基础上可以更改播放起始点。为了实现动态地的更换播放的资产和调整播放时间，因此它们在细节面板中<code>Sequence</code>和<code>Explicit Time</code>（仅限 Evaluator）都会更改成<code>Dynamic</code>形式。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-sequence_player_set_dynamic.png"></p><p>对于这两个播放节点会绑定<code>On Become Relevant</code>和<code>On Update</code>函数：前者代表这个序列开始贡献姿势的第一帧，也就是权重值不再是 0% 了；后者就是每帧都会调用的函数。在函数内部通常对<code>Node</code>形参调用<code>Convert to Sequence Player</code> 或 <code>Convert to Sequence Evaluator</code>，从而进一步设置播放的 Sequence 以及设置 Explicit Time（仅限 Evaluator）。在上文中讲述过开始、停止和枢轴动画中加入了 Distance 曲线。对于它们来说我们可以在<code>Sequence Evaluator</code>的<code>On Update</code>函数中调用<code>Advance Time by Distance Matching</code>节点，将当前帧与上一帧角色移动的位置差作为参数就可以转换为播放的帧起始点。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-Advance_Time_by_Distance_Matching.png"></p><p>对于停止动画会使用<code>Predict Ground Movement Stop Location</code>来计算出停止的位置出，得到向量长度后可以使用<code>Distance Match to Target</code>节点来调整<code>Explicit Time</code>。在 Lyra 中计算距离值的逻辑封装为了<code>Get Predicted Stop Distance</code>函数。</p><p><img src="/2024/03/24/Advanced-Locomotion-Animation-Logic/freecompress-get_predicted_stop_distance.png"></p><h2 id="在运行时链接动画层"><a href="#在运行时链接动画层" class="headerlink" title="在运行时链接动画层"></a>在运行时链接动画层</h2><p>在 Lyra 解决方案中，角色类使用的动画蓝图类是<code>ABP_Mannequin_Base</code>，但从上一节的描述中已经知道这个蓝图类中没有具体的动画资产，所以直接使用只会得到 T-Pose。为了链接到实现了动画层的动画蓝图，可以使用下面的函数来动态的链接和取消链接动画蓝图：</p><pre><code class="hljs CPP"><span class="hljs-comment">// 参数为实现了动画层的动画蓝图类</span><span class="hljs-built_in">GetMesh</span>()-&gt;<span class="hljs-built_in">LinkAnimClassLayers</span>(); <span class="hljs-built_in">GetMesh</span>()-&gt;<span class="hljs-built_in">UnlinkAnimClassLayers</span>();</code></pre><p>但直接调用这个函数并不会进行网络同步，需要定义一个<code>NetMulticast</code>函数来确保所有客户端中都可以看到这个链接函数。以下是一个示例，如果第二个参数为 true 就调用 Link 函数，否则就调用 Unlink 函数：</p><pre><code class="hljs CPP"><span class="hljs-built_in">UFUNCTION</span>(NetMulticast, Reliable)<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Multicast_SetMeshCompAnimLayers</span><span class="hljs-params">(TSubclassOf&lt;UAnimInstance&gt; InClass, <span class="hljs-type">bool</span> bLinkIt = <span class="hljs-literal">true</span>)</span></span>;</code></pre><p>可装备道具在设计时可以加入一个 TSubclassOf<uaniminstance> 类型的变量，要求设计师指定一个实现了动画层的动画蓝图类，在运行时调用<code>Multicast_SetMeshCompAnimLayers</code>函数以便于动态地调整姿势。</uaniminstance></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自虚幻引擎5发布以来，Epic 官方提供了很多实用的工具来处理动画资产，在初学者项目 Lyra 中不仅可以看到这些工具的具体应用，还提供了一个进阶版本的动画逻辑解决方案（相较于第三人称射击模板附带的动画蓝图）。本博文主要讨论这套方案的以下几个要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="Animation" scheme="http://www.yerha.top/tags/Animation/"/>
    
    <category term="Lyra" scheme="http://www.yerha.top/tags/Lyra/"/>
    
  </entry>
  
  <entry>
    <title>如何将建造功能作为一种技能</title>
    <link href="http://www.yerha.top/2024/03/10/Implement_Building_System_With_GAS/"/>
    <id>http://www.yerha.top/2024/03/10/Implement_Building_System_With_GAS/</id>
    <published>2024-03-10T13:38:48.000Z</published>
    <updated>2024-03-24T02:05:12.942Z</updated>
    
    <content type="html"><![CDATA[<center>(最终效果展示)</center><p><img src="/2024/03/10/Implement_Building_System_With_GAS/building_structures_with_gas.gif"></p><p>在很多提供建造玩法的项目案例中，往往是定义 ActorComponent 类并在那里实现启用建造功能、选择建造位置、轻微调整建筑物、生成建筑物等功能，随后角色类会使用该 ActorComponent 的实例，从而获得建造建筑的能力。这需要开发者处理玩家能否启用建造功能，例如当玩家获得阵亡、沉睡、眩晕等状态时需要阻止建筑功能逻辑的执行，并且停止正在进行的建造进程。</p><p>除此之外，很多解决方案还采取了引入若干个碰撞频道来实现建筑物对齐功能，这会至少引发三个问题：1. 迁移代码到其他项目时总是需要添加这些额外的碰撞频道；2. 每次引入新的碰撞频道时，需要检查之前的建筑物是否已经忽略了新频道，避免出现错误的对齐；3. 开发者需要检查每个 BoxComponent 是否正确阻挡了对应的频道，增加了因开发者分心、遗忘所造成的程序错误逻辑概率。所以这篇博客集中于以下几点实现建造功能：</p><ul><li>将建造功能作为一项 Ability 来实现，后期玩家获得的状态影响着玩家是否能够激活该技能；</li><li>设计师只需要按照命名规范为 BoxComponent 起合适的名字，并调整对齐位置点即可。</li></ul><h2 id="建筑物的识别与对齐"><a href="#建筑物的识别与对齐" class="headerlink" title="建筑物的识别与对齐"></a>建筑物的识别与对齐</h2><p>在玩家尝试进行一次建造物的生成时，通常更愿意将其摆放在已存在建筑物的附近，因此为玩家提供辅助对齐的机制尤为重要。在建筑物类内部可以看到很多 BoxComponent 出现在 StaticMeshComponent 的附近，它们用于指定可以摆放在那里的建筑类类型。在下图中，可以看到地基类建筑可以设置其他地基、墙壁可以对齐的位置。</p><p><img src="/2024/03/10/Implement_Building_System_With_GAS/demo_foundation_structure.png"></p><p>在玩家挪动预览建筑物的位置时，射线追踪的结果会尝试寻找匹配的 BoxComponent，如果建筑物类型匹配则设置预览建筑物的变换到该 BoxComponent 的。具体的逻辑实现在下一节中展开详述，本节讨论如何为 BoxComponent 附上合适的建筑物类型。</p><p>我个人比较喜欢的是让每一个行为都有意义，包括为 BoxComponent 实例命名。在上图左上角可以看到<code>FoundationX</code>、<code>WallX</code>格式的名字，这些数字（X）前面的字符串就为 BoxComponent 定义了类型。这样名字不仅帮助设计师区分不同组件，还进一步确定了它可以对齐的建筑物类型（如建筑物类型为 Wall 的实例只能对齐到 Wall 开头的 BoxComponent 中）。为实现这种名称决定类型的功能，我们需要一个枚举类和 BoxComponent 派生类，具体实现如下：</p><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">EStructureType</span> : uint8{None,Foundation,Wall,<span class="hljs-comment">// other stuff</span>};<span class="hljs-keyword">class</span> <span class="hljs-title class_">UBota_BoxComponent</span> : <span class="hljs-keyword">public</span> UBoxComponent; <span class="hljs-function">EStructureType <span class="hljs-title">UBota_BoxComponent::GetCollisionType</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>{<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; EnumPtr = <span class="hljs-built_in">FindObject</span>&lt;UEnum&gt;(ANY_PACKAGE, <span class="hljs-built_in">TEXT</span>(<span class="hljs-string">"EStructureType"</span>), <span class="hljs-literal">true</span>);<span class="hljs-keyword">for</span> (int32 i = <span class="hljs-number">0</span>; i &lt; EnumPtr-&gt;<span class="hljs-built_in">NumEnums</span>(); ++i){<span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetNameSafe</span>(<span class="hljs-keyword">this</span>).<span class="hljs-built_in">StartsWith</span>(EnumPtr-&gt;<span class="hljs-built_in">GetNameStringByIndex</span>(i))){<span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;EStructureType&gt;(EnumPtr-&gt;<span class="hljs-built_in">GetValueByIndex</span>(i));}}<span class="hljs-keyword">return</span> EStructureType::None;}</code></pre><p>在上述代码中<code>EStructureType</code>决定了当前项目中有哪些建筑物类型。自定义的<code>UBota_BoxComponent</code>提供了返回建筑类型的函数，在函数体内会根据自己的名字找到匹配的建筑枚举项并返回。这种实现方式使用到了虚幻引擎提供的反射机制，设计师也可以随时在<code>EStructureType</code>添加新的建筑物类型，而无需修改<code>UBota_BoxComponent</code>的代码。</p><p>在很多解决方案中，摧毁一个建筑物可能会引发其他建筑物的一同销毁，例如一块地基建筑物被销毁时会连同周围的墙壁、墙壁附近的物品一起销毁，但不会影响其他地基建筑物的销毁，此时可以遍历 <code>UBota_BoxComponent</code> 组件从而筛选出满足条件的建筑物。</p><h2 id="实现技能前的准备工作"><a href="#实现技能前的准备工作" class="headerlink" title="实现技能前的准备工作"></a>实现技能前的准备工作</h2><p>在 GAS 插件下，需要玩家挑选和确认施法位置时会用到继承自<code>AGameplayAbilityTargetActor</code>的类实例（以下简称 TargetActor）。除了作为一个 Actor 存在，它还封装了一个<code>FGameplayAbilityTargetData</code>（以下简称 TargetData），在玩家发出确认目标的请求时就会将处理后的信息封装成<code>FGameplayAbilityTargetDataHandle</code>（以下简称 TargetDataHandle）然后以委托的形式传递出去，这是一种在 Ability 类中客户端向服务器通信发送数据的方式。</p><p>虚幻官方提供了如 GroundTace、SingleLineTrace 等派生类供开发者直接使用，这些派生类会在射线追踪中将<code>FGameplayAbilityTargetingLocationInfo</code>的实例传递出去，在一些仅需要位置信息的技能中很有用。然而对于建造技能来说，除了位置信息我们还需要知道玩家设置的旋转信息，以便于建筑物拥有玩家预期的变换。因此需要：</p><ol><li>能够传递位置和旋转信息（这里假设了缩放大小保持在 1）；</li><li>作为预览建筑物的 TargetActor 能尝试寻找<code>UBota_BoxComponent</code>实例并对齐；</li><li>能在自定义的 TargetData 和 TargetDataHandle 之间来回转换。</li></ol><p>自定义 TargetData 中最关键的要求就是变量类型实现了网络序列化（有<code>NetSerialize</code>函数可用），在本案例中，<code>FVector_NetQuantize100</code>和<code>FRotator</code>都被虚幻引擎官方实现了网络序列化，故整个工作流程就只是使用如同下面的模板来定义一个 TargetData：</p><pre><code class="hljs C++"><span class="hljs-built_in">USTRUCT</span>(BlueprintType)<span class="hljs-keyword">struct</span> <span class="hljs-title class_">BOTA_API</span> FGameplayAbilityTargetData_LocationAndRotation : <span class="hljs-keyword">public</span> FGameplayAbilityTargetData{<span class="hljs-built_in">GENERATED_BODY</span>()<span class="hljs-built_in">FGameplayAbilityTargetData_LocationAndRotation</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)FVector_NetQuantize100 Location;<span class="hljs-built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite)FRotator Rotation;<span class="hljs-function"><span class="hljs-keyword">virtual</span> UScriptStruct* <span class="hljs-title">GetScriptStruct</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">return</span> FGameplayAbilityTargetData_LocationAndRotation::<span class="hljs-built_in">StaticStruct</span>();}<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NetSerialize</span><span class="hljs-params">(FArchive&amp; Ar, <span class="hljs-keyword">class</span> UPackageMap* Map, <span class="hljs-type">bool</span>&amp; bOutSuccess)</span></span><span class="hljs-function"></span>{Location.<span class="hljs-built_in">NetSerialize</span>(Ar, Map, bOutSuccess);Rotation.<span class="hljs-built_in">NetSerialize</span>(Ar, Map, bOutSuccess);bOutSuccess = <span class="hljs-literal">true</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;}};<span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">TStructOpsTypeTraits</span>&lt;FGameplayAbilityTargetData_LocationAndRotation&gt; : <span class="hljs-keyword">public</span> TStructOpsTypeTraitsBase2&lt;FGameplayAbilityTargetData_LocationAndRotation&gt;{<span class="hljs-keyword">enum</span>{WithNetSerializer = <span class="hljs-literal">true</span> };};</code></pre><p>接下来的任务就是定义 TargetActor，作为预览建筑物辅助玩家选择要将建筑物放置在哪里。TargetActor 有几个信息可以先了解一下（函数无签名信息）：</p><ul><li><code>StartTargeting()</code>：初始化函数，可以得到 Ability 的信息，进而获得 Avatar、AbilitySystemComponent （以下简称 ASC）等信息。从而在<code>Tick()</code>函数中找到玩家的位置和看向的方向，确定射线追踪的参数。</li><li><code>ConfirmTargetingAndContinue()</code>：玩家对 ASC 调用了 <code>TargetConfirm()</code> 函数，代表玩家此时决定在此处生成 TargetData。在本例中代表玩家已经确定了新建筑物要放置在哪里。</li><li><code>IsConfirmTargetingAllowed()</code>：通常在上一条函数中调用，有时 TargetActor 所掌握的信息不能生成 TargetData，返回一个布尔值来信息是否满足条件。在本例中，墙壁类建筑物不允许随意放置，只允许放置在 UBota_BoxComponent 的类型是 Wall 之中，具体来说必须在地基或者其他墙壁之上，所以出现在其他地方时阻止玩家生成建筑物实例。</li><li><code>StartLocation</code>：一个 FGameplayAbilityTargetingLocationInfo 类型的实例，包含一个位置信息可以广播。</li></ul><p>本例定义了一个派生自<code>AGameplayAbilityTargetActor_SingleLineTrace</code>的新类，覆盖了其<code>Tick()</code>、<code>ConfirmTargetingAndContinue()</code>和<code>IsConfirmTargetingAllowed()</code>函数。</p><p>在 Tick 函数会展开射线追踪检测，得到 FHitResult 实例后判断 Component 是否为 Bota_BoxComponent，如果是就设置 TargetActor 为 Component 的变换，否则就使用射线检测的 TraceEnd 作为 TargetActor 的位置。由于基类假设的是玩家并不会移动，但我们希望玩家可以边移动边选择放置处，这意味着需要更新<code>StartLocation</code>的信息：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PreviewTargetActor::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaSeconds)</span></span><span class="hljs-function"></span>{StartLocation.LiteralTransform.<span class="hljs-built_in">SetLocation</span>(SourceActor-&gt;<span class="hljs-built_in">GetActorLocation</span>());<span class="hljs-keyword">auto</span> HitResult = <span class="hljs-built_in">PerformTrace</span>(SourceActor);BuildTransform.<span class="hljs-built_in">SetLocation</span>(HitResult.Component.<span class="hljs-built_in">IsValid</span>() ? HitResult.ImpactPoint : HitResult.TraceEnd);bCanBuild = bFreePlacement;<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Component = <span class="hljs-built_in">Cast</span>&lt;UBota_BoxComponent&gt;(HitResult.Component)){<span class="hljs-keyword">if</span> (Component-&gt;<span class="hljs-built_in">GetCollisionType</span>() == StructureType){BuildTransform.<span class="hljs-built_in">SetLocation</span>(Component-&gt;<span class="hljs-built_in">GetComponentLocation</span>());BuildTransform.<span class="hljs-built_in">SetRotation</span>(Component-&gt;<span class="hljs-built_in">GetComponentRotation</span>().<span class="hljs-built_in">Quaternion</span>());bCanBuild = <span class="hljs-literal">true</span>;}}<span class="hljs-built_in">SetActorTransform</span>(BuildTransform);}</code></pre><p>通常在建造游戏中玩家可以使用<code>Q</code> <code>E</code>或者鼠标滚轮实现预览建筑物在 Yaw 轴上进行旋转，为了实现这个功能，可以引入两个<code>GameplayTag</code>并在对应按键按下和释放时分别对<code>ASC</code>调用<code>AddLooseGameplayTag()</code>和<code>RemoveLooseGameplayTag()</code>，使得 TargetActor 和玩家之间通过标签来通信，具体实现是：</p><pre><code class="hljs C++"><span class="hljs-comment">// Bota_GameplayTags.cpp</span><span class="hljs-built_in">UE_DEFINE_GAMEPLAY_TAG</span>(Tag_Input_Rotate_Up, <span class="hljs-string">"Input.Rotate.Up"</span>);<span class="hljs-built_in">UE_DEFINE_GAMEPLAY_TAG</span>(Tag_Input_Rotate_Down, <span class="hljs-string">"Input.Rotate.Down"</span>);<span class="hljs-comment">// Bota_PlayerCharacter.cpp 仅展示了 Rotate_Down 标签</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PlayerCharacter::OnRotateBuildingPressed</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">AddLooseGameplayTag</span>(Tag_Input_Rotate_Down);}}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PlayerCharacter::OnRotateBuildingReleased</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = <span class="hljs-built_in">GetAbilitySystemComponent</span>()){ASC-&gt;<span class="hljs-built_in">RemoveLooseGameplayTag</span>(Tag_Input_Rotate_Down);}}<span class="hljs-comment">// Bota_PreviewTargetActor.cpp</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PreviewTargetActor::Tick</span><span class="hljs-params">(<span class="hljs-type">float</span> DeltaSeconds)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">// ... 与之前相同</span><span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ASC = UAbilitySystemBlueprintLibrary::<span class="hljs-built_in">GetAbilitySystemComponent</span>(SourceActor)){<span class="hljs-keyword">auto</span> NewRotation = BuildTransform.<span class="hljs-built_in">Rotator</span>();<span class="hljs-keyword">if</span> (ASC-&gt;<span class="hljs-built_in">GetGameplayTagCount</span>(Tag_Input_Rotate_Down)){NewRotation = UKismetMathLibrary::<span class="hljs-built_in">ComposeRotators</span>(NewRotation, <span class="hljs-built_in">FRotator</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>));}<span class="hljs-keyword">if</span> (ASC-&gt;<span class="hljs-built_in">GetGameplayTagCount</span>(Tag_Input_Rotate_Up)){NewRotation = UKismetMathLibrary::<span class="hljs-built_in">ComposeRotators</span>(NewRotation, <span class="hljs-built_in">FRotator</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">0</span>));}BuildTransform.<span class="hljs-built_in">SetRotation</span>(NewRotation.<span class="hljs-built_in">Quaternion</span>());}<span class="hljs-comment">// ... 与之前相同</span>}</code></pre><p>接下来需要考虑实现如何将自定义的 TargetData 封装为 TargetDataHandle，并在<code>ConfirmTargetingAndContinue()</code> 中广播出去。下面的代码是比较模板化的代码，结构体实例也通常使用 C++ 的<code>new</code>关键字来创建实例并对实例的数据成员赋值，最后新定义一个 TargetDataHandle 并将刚才的实例添加进去并返回。</p><pre><code class="hljs C++"><span class="hljs-function">FGameplayAbilityTargetDataHandle  <span class="hljs-title">ABota_PreviewTargetActor::MakeTargetData_LocationAndRotation</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-keyword">auto</span> Data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FGameplayAbilityTargetData_LocationAndRotation</span>();Data-&gt;Location = <span class="hljs-built_in">GetActorLocation</span>();Data-&gt;Rotation = <span class="hljs-built_in">GetActorRotation</span>();<span class="hljs-keyword">auto</span> Handle = <span class="hljs-built_in">FGameplayAbilityTargetDataHandle</span>();Handle.<span class="hljs-built_in">Add</span>(Data);<span class="hljs-keyword">return</span> Handle;}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ABota_PreviewTargetActor::ConfirmTargetingAndContinue</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{<span class="hljs-built_in">check</span>(<span class="hljs-built_in">ShouldProduceTargetData</span>());<span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsConfirmTargetingAllowed</span>()){bDebug = <span class="hljs-literal">false</span>;FGameplayAbilityTargetDataHandle Handle = <span class="hljs-built_in">MakeTargetData_LocationAndRotation</span>();TargetDataReadyDelegate.<span class="hljs-built_in">Broadcast</span>(Handle);}}</code></pre><p>在蓝图中，自定义的 TargetData 并没有直接的方法来获得里面存储的位置和旋转信息，因此需要实现一个单独的函数来将 TargetDataHandle 里面存储的自定义 TargetData 读取出来。这个函数可以是静态的，可以定义在 <code>UGameplayAbility</code> 或者 <code>UBlueprintFunctionLibrary</code> 中，本例中实现在了 GA 下：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UBota_GameplayAbility::GetTransformFromTargetData</span><span class="hljs-params">(FGameplayAbilityTargetDataHandle Handle, <span class="hljs-type">const</span> <span class="hljs-type">int</span> Index, FTransform&amp; Transform)</span></span><span class="hljs-function"></span>{    FGameplayAbilityTargetData* Data = Handle.<span class="hljs-built_in">Get</span>(Index);    <span class="hljs-keyword">if</span> (!Data)    {        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">if</span> (Data-&gt;<span class="hljs-built_in">GetScriptStruct</span>() == FGameplayAbilityTargetData_LocationAndRotation::<span class="hljs-built_in">StaticStruct</span>())    {        <span class="hljs-keyword">auto</span> MyData = <span class="hljs-built_in">static_cast</span>&lt;FGameplayAbilityTargetData_LocationAndRotation*&gt;(Data);        Transform.<span class="hljs-built_in">SetLocation</span>(MyData-&gt;Location);        Transform.<span class="hljs-built_in">SetRotation</span>(MyData-&gt;Rotation.<span class="hljs-built_in">Quaternion</span>());        Transform.<span class="hljs-built_in">SetScale3D</span>(<span class="hljs-built_in">FVector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));    }}</code></pre><h2 id="实现技能逻辑"><a href="#实现技能逻辑" class="headerlink" title="实现技能逻辑"></a>实现技能逻辑</h2><p>在本例中将技能逻辑的实现放在了蓝图，这是因为预览建筑物类中设置了一些<code>Expose On Spawn</code> 的变量，我暂时在 C++ 中没有找到在技能任务执行之前，对这些变量初始化的办法。在蓝图中，我将技能的触发器设置为由 <code>GameplayEvent</code> 触发并且约定<code>Optional Object</code>中存储着建筑类的信息。随后调用<code>WaitTargetData</code>任务并选择之前定义的预览建筑物 TargetActor 并设置好建筑物信息，在<code>Valid Data</code>执行中让服务器生成具体的 Actor 实例，进一步设置<code>Owner</code>为玩家，这样就可以在建筑物类中定义<code>RPC</code>并不会报没有网络链路的错误了，在本例中开关门的动作就是调用 Server 函数，随后 NetMulticast 执行开关门的动画。蓝图节点的总览如下：</p><p><img src="/2024/03/10/Implement_Building_System_With_GAS/ga_build_screenshot.png" alt="GA_Build"></p><h2 id="触发技能的执行"><a href="#触发技能的执行" class="headerlink" title="触发技能的执行"></a>触发技能的执行</h2><p>在本例中，我使用一个 <code>class UBota_StructureDataAsset : public UPrimaryDataAsset</code> 来存储着建筑物的信息，有些如建筑物的名字、缩略图等信息定义在此处，而具体的网格资产和逻辑都是在 Actor 类中选择。在预览建筑物 TargetActor 中找到建筑物类的类默认对象，从而读取网格资产信息。这样就不用在<code>DataAsset</code>和建筑物类中设置两次网格资产等其他信息，减少重复性行为。</p><pre><code class="hljs C++"><span class="hljs-comment">// Bota_PreviewTargetActor.cpp</span><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; DefaultStructureActor = <span class="hljs-built_in">GetDefault</span>&lt;ABota_StructureActor&gt;(StructureDataAsset-&gt;ActorToSpawn);StructureType = DefaultStructureActor-&gt;StructureType;<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; Mesh = DefaultStructureActor-&gt;StaticMeshComponent-&gt;<span class="hljs-built_in">GetStaticMesh</span>();StaticMeshComponent-&gt;<span class="hljs-built_in">SetStaticMesh</span>(Mesh);bFreePlacement = DefaultStructureActor-&gt;bFreePlacement;</code></pre><p>在<code>AssetManager</code>中添加<code>UBota_StructureDataAsset</code>后就可以使用 <code>Get Primary Asset Id List</code> 和 <code>Async Load Primary Asset List</code> 节点来加载所有建筑物了。选择需要建造的建筑物后，就可以调用 <code>Send Gameplay Event To Actor</code>来触发技能的执行了。</p><p><img src="/2024/03/10/Implement_Building_System_With_GAS/try_active_build_ability_by_tag.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;center&gt;(最终效果展示)&lt;/center&gt;

&lt;p&gt;&lt;img src=&quot;/2024/03/10/Implement_Building_System_With_GAS/building_structures_with_gas.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;在很多提供建造玩法的项</summary>
      
    
    
    
    
    <category term="Unreal" scheme="http://www.yerha.top/tags/Unreal/"/>
    
    <category term="GAS" scheme="http://www.yerha.top/tags/GAS/"/>
    
    <category term="BuildingSystem" scheme="http://www.yerha.top/tags/BuildingSystem/"/>
    
  </entry>
  
</feed>
